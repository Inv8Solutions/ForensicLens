
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
	<title>Level 3: Blood</title>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;400&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
	<style>
		:root { --topbar-h: 64px; --gutter: 16px; }
		html, body {
			height: 100vh;
			margin: 0;
			padding: 0;
			background: #18181a;
			color: #fff;
			font-family: 'Inter', 'Montserrat', Arial, sans-serif;
			width: 100vw;
			overflow: hidden; /* prevent scrolling */
		}
		body {
			height: 100vh;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: flex-start;
			box-sizing: border-box;
		}
		@media only screen and (orientation: portrait) {
			body::before {
				content: 'Please rotate your device';
				position: fixed;
				z-index: 9999;
				top: 0; left: 0; right: 0; bottom: 0;
				background: #18181a;
				color: #fff;
				font-size: 2rem;
				display: flex;
				align-items: center;
				justify-content: center;
				text-align: center;
			}
			#main-content { display: none !important; }
		}
		/* Layout: left image, right controls */
		.layout, .flex-row {
			display: flex;
			flex-direction: row;
			gap: 32px;
			align-items: stretch;
			justify-content: center;
			width: calc(100vw - (var(--gutter) * 2));
			max-width: 1240px;
			margin: 0 auto;
			padding: 8px var(--gutter) 16px var(--gutter);
			box-sizing: border-box;
			height: calc(100vh - var(--topbar-h) - 24px);
			overflow: hidden;
		}
		.left,
		.flex-left {
			flex: 1.2;
			display: flex;
			flex-direction: column;
			align-items: center;
			min-width: 0;
			height: 100%;
			justify-content: space-between;
			padding-bottom: 8px;
		}
		.right,
		.flex-right {
			flex: 1;
			background: #232326;
			border-radius: 20px;
			border: 2px solid #b3b3b733;
			padding: 12px 12px 12px 12px;
			box-sizing: border-box;
			min-width: 220px;
			max-width: 420px;
			display: flex;
			flex-direction: column;
			gap: 20px;
			height: 100%;
			overflow: hidden;
		}
		.back-btn {
			position: absolute;
			top: 32px;
			left: 0; /* will be repositioned inside top-bar */
			background: #232326;
			border-radius: 14px;
			width: 56px;
			height: 56px;
			display: flex;
			align-items: center;
			justify-content: center;
			border: none;
			box-shadow: 0 2px 8px #0002;
			cursor: pointer;
			z-index: 2;
		}
		.back-btn svg {
			width: 28px;
			height: 28px;
			fill: #b3b3b7;
		}
		.level-title {
			font-family: 'Montserrat', Arial, sans-serif;
			font-size: 20px;
			font-weight: 700;
			text-align: left;
			margin: 0 0 0 0;
			margin-left: 96px;
			margin-top: 0;
			margin-bottom: 0;
			letter-spacing: 1px;
			position: relative;
			top: 18px;
		}
		.task-box {
			background: #232326;
			color: #fff;
			border-radius: 20px;
			padding: 16px 32px;
			font-size: 12px;
			font-weight: 400;
			margin: 0 0 0 24px;
			max-width: 620px;
			box-sizing: border-box;
			border: 2px solid #b3b3b733;
			position: relative;
			z-index: 1;
		}
		.top-bar {
			display: flex;
			align-items: center;
			gap: 18px;
			width: 100%;
			max-width: 1240px;
			margin: 12px auto 0 auto;
			padding: 0 var(--gutter);
			box-sizing: border-box;
			height: var(--topbar-h);
		}
		/* When top-bar exists, make back-btn static inside it */
		.top-bar .back-btn { position: static; }
		.photo-box {
			width: 100%;
			max-width: 720px;
			flex: 1 1 auto;
			background: #111;
			border-radius: 20px;
			border: 2px solid #b3b3b733;
			overflow: hidden;
			margin-bottom: 18px;
			display: flex;
			align-items: center;
			justify-content: center;
			position: relative;
		}
		.photo-box img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			display: block;
		}
		.exposure-label {
			text-align: center;
			font-size: 1.2rem;
			font-weight: 500;
			margin-bottom: 8px;
			margin-top: 8px;
		}
		.exposure-label span {
			font-weight: 700;
		}
		.exposure-slider {
			width: 100%;
			margin: 0 auto 0 auto;
			display: flex;
			flex-direction: column;
			align-items: center;
		}
		.slider-track {
			width: 95%;
			margin: 0 auto;
			position: relative;
			height: 36px;
			display: flex;
			align-items: center;
		}
		/* ticks under sliders */
		.ticks {
			display: block;
			width: 95%;
			margin: -5px auto 0 auto;
			height: 10px;
			position: relative;
		}
		.ticks span {
			position: absolute;
			bottom: 2px;
			width: 2px;
			height: 6px; /* shorter tick */
			background: #666;
			transform: translateX(-50%);
		}
		.ticks label {
			position: absolute;
			bottom: -12px; /* closer label */
			transform: translateX(-50%);
			font-size: 10px;
			color: #b3b3b7;
		}
		.slider {
			width: 100%;
			accent-color: #ff3b3f;
			height: 4px;
			margin: 0;
		}
		/* Exposure meter styles */
		.meter-container {
			width: 100%;
			height: 24px;
			background: linear-gradient(to right, #333, #666);
			border-radius: 12px;
			position: relative;
			margin: 8px 0;
			border: 1px solid #555;
		}
		.meter-indicator {
			position: absolute;
			top: 2px;
			width: 20px;
			height: 20px;
			background: #ff3b3f;
			border-radius: 50%;
			transform: translateX(-50%);
			transition: left 0.2s ease;
			border: 2px solid #fff;
			box-shadow: 0 2px 4px rgba(0,0,0,0.3);
		}
		.slider-labels {
			width: 95%;
			display: flex;
			justify-content: space-between;
			font-size: 1.1rem;
			color: #b3b3b7;
			margin-top: 2px;
			margin-bottom: 0;
		}
		.controls-title {
			font-family: 'Montserrat', Arial, sans-serif;
			font-size: 13px;
			font-weight: 700;
			margin-bottom: -10px;
			margin-top: 0;
			display: flex;
			align-items: center;
			gap: 3px;
		}
		/* Slightly tighten the top of controls area */
		.controls-inner { padding-top: 1px; }
		.control-group {
			margin-bottom: 12px;
            
		}
		.control-label {
			font-size: 12px;
			font-weight: 500;
			margin-bottom: 6px;
			display: flex;
			align-items: center;
			gap: 6px;
			margin-bottom: -5px;
		}
		.control-slider {
			width: 100%;
			accent-color: #ff3b3f;
			margin: 0 0 6px 0;
			height: 28px;
		}
		.control-range-labels {
			display: flex;
			justify-content: space-between;
			font-size: 9px;
			color: #b3b3b7;
			margin-bottom: 0;
		}

		.reset-btn, .btn.reset {
			background: none;
			color: #fff;
			border: 1px solid #b3b3b7;
			border-radius: 10px;
			font-size: 0.95rem;
			font-weight: 500;
			padding: 8px 14px;
			cursor: pointer;
			transition: background 0.2s, color 0.2s;
		}
		.reset-btn:hover, .btn.reset:hover {
			background: #232326;
			color: #ff3b3f;
		}
		.submit-btn, .btn.submit {
			flex:1;
			background: #ff3b3f;
			color: #fff;
			border: none;
			border-radius: 10px;
			font-size: 0.95rem;
			font-weight: 700;
			padding: 8px 12px;
			cursor: pointer;
			box-shadow: 0 2px 8px #ff3b3f22;
			transition: background 0.2s;
		}
		.submit-btn:hover, .btn.submit:hover {
			background: #e22e32;
		}

		/* Make the right column scroll internally if needed */
		.flex-right .controls-inner { overflow:auto; max-height: calc(100% - 50px); padding-right: 6px; }
		@media (max-width: 1100px) {
			.layout { flex-direction: column; align-items: center; gap: 12px; height: auto; }
			.task-box { position: static; margin: 12px 0; max-width: 100vw; width: 100%; }
			.level-title { margin-left: 0; text-align: left; top: 0; }
			.top-bar { padding: 0 12px; }
		}
		@media (max-width: 700px) {
			.layout { padding: 8px 6px 0 6px; gap: 12px; }
			.photo-box { width: 100%; height: 40vw; min-height: 140px; max-width: 100%; }
			.right { min-width: 0; max-width: 100vw; padding: 12px 8px; }
			.top-bar { padding: 0 10px; }
		}

		/* Result modal styles */
		.fl-modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0,0,0,0.6);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 9998;
		}
		.fl-modal-overlay[aria-hidden="false"] { display: flex; }
		.fl-modal {
			width: calc(100% - 64px);
			max-width: 420px;
			background: #0f0f10;
			border-radius: 16px;
			padding: 18px;
			box-shadow: 0 8px 30px rgba(0,0,0,0.6);
			color: #fff;
			border: 1px solid #2b2b2b;
			text-align: center;
		}
		.fl-icon {
			width: 96px;
			height: 96px;
			margin: 6px auto 10px auto;
			display: flex;
			align-items: center;
			justify-content: center;
			background: transparent;
			box-shadow: none;
		}
		.fl-icon i { font-size: 64px; line-height: 1; }
		.fl-icon.success i { color: #22c55e; }
		.fl-icon.fail i { color: #ef4444; }
		.fl-modal h2 { margin: 8px 0 6px 0; font-size: 20px; }
		.fl-modal p { margin: 0 0 12px 0; color: #d1d1d1; }
		.fl-settings { display:flex; gap: 10px; justify-content: center; margin: 10px 0 14px 0; }
		.fl-col { min-width: 120px; }
		.fl-col-title { font-weight:700; font-size: 12px; color: #fff; margin-bottom: 6px; }
		.fl-list p { margin: 4px 0; font-size: 13px; color:#dcdcdc; }
		.fl-actions { display:flex; gap:10px; justify-content: center; }
		.fl-btn { padding: 10px 12px; border-radius: 10px; font-weight:700; cursor:pointer; border: none; }
		.fl-ghost { background: transparent; border: 1px solid #555; color: #fff; }
		.fl-primary { background: #ff3b3f; color: #fff; }
	</style>
	<style>
        /* Canvas photo styling */
        #photo-canvas { width: 100%; height: 100%; display: block; }
    </style>
		<style>
			/* Buttons under settings */
			.controls-btns { display:flex; gap:12px; justify-content: space-between; margin-top: 6px; }
			.btn { flex:1; padding: 10px 12px; border-radius: 12px; border: none; font-weight: 600; cursor: pointer; }
			.btn.reset { background: #2b2b2b; color: #fff; border: 1px solid #555; }
			.btn.submit { background: #e22e32; color: #fff; border: 1px solid #555; }
			.btn:active { transform: translateY(1px); }
		</style>

		<!-- Camera Modes styles -->
		<style>
			.modes { display: flex; gap: 5px; background: #1b1b1d; border: 1px solid #2b2b2b; border-radius: 14px; padding: 2px;}
			.modes .mode { flex: 1; background: #2a2a2e; color: #ddd; border: 1px solid #2f2f2f; border-radius: 12px; padding: 1px 12px; font-weight: 700; cursor: pointer; text-align: center; }
			.modes .mode.active { background: #d6d6da; color:#1b1b1d; border-color:#bdbdc2; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
		</style>

		<!-- Disabled controls styles for Tv/Av modes -->
		<style>
			.control-group.control-disabled { opacity: 0.45; filter: grayscale(40%); }
			.control-group.control-disabled .control-slider:disabled { cursor: not-allowed; }
			.control-slider:disabled { opacity: 0.8; cursor: not-allowed; }
		</style>

			<style>
				/* Oblique lighting toggle visual styles */
				.oblique-toggle { 
					display:flex; 
					align-items:center; 
					gap:8px; 
					justify-content:space-between; 
					padding:10px 12px; 
					border-radius:12px; 
					background:#171718; 
					border:1px solid #2b2b2b; 
					color:#ddd; 
					font-weight:700; 
					cursor:pointer; 
					width:100%; 
					transition: background 160ms, color 160ms, box-shadow 160ms; 
				}
				.oblique-toggle.active { 
					background: linear-gradient(90deg,#ffd700,#ffb347); 
					color:#332200; 
					box-shadow:0 6px 18px rgba(255,179,71,0.12); 
				}
				.three-dots {
					display: flex;
					gap: 2px;
					align-items: center;
				}
				.three-dots span {
					width: 4px;
					height: 4px;
					border-radius: 50%;
					background: currentColor;
					opacity: 0.7;
				}
				.oblique-toggle.active .three-dots span {
					opacity: 1;
				}
				
				/* Oblique angle selection buttons */
				.oblique-angle-btn:hover {
					background: #3a3a3a !important;
					border-color: #777 !important;
				}
				.oblique-angle-btn.active {
					background: linear-gradient(90deg,#ffd700,#ffb347) !important;
					color: #332200 !important;
					border-color: #ffb347 !important;
				}
			</style>
	    <script type="module" src="../algo/firebase.js"></script>
	    <script src="../algo/algo.js"></script>
	<script>
			// Simple toast for submit feedback
			function showToast(msg) {
				let t = document.getElementById('fl-toast');
				if(!t) {
					t = document.createElement('div');
					t.id = 'fl-toast';
					t.style.position = 'absolute';
					t.style.bottom = '18px';
					t.style.left = '50%';
					t.style.transform = 'translateX(-50%)';
					t.style.background = 'rgba(0,0,0,0.8)';
					t.style.color = '#fff';
					t.style.padding = '10px 14px';
					t.style.borderRadius = '12px';
					t.style.zIndex = 9999;
					document.body.appendChild(t);
				}
				t.textContent = msg;
				setTimeout(()=>{ if(t) t.remove(); }, 1800);
			}

			// Reset and Submit handlers
			document.addEventListener('DOMContentLoaded', ()=>{
				// wire modal action buttons
				document.getElementById('fl-try').addEventListener('click', ()=>{ closeResultModal(); });
				// Use progression engine to mark Practice 3 complete and go to Quiz 3
				document.getElementById('fl-next').addEventListener('click', (e)=>{
					try{ e.preventDefault(); }catch(_){ }
					if(window.ForensicFlow && typeof ForensicFlow.onPractice3Finished === 'function'){
						ForensicFlow.onPractice3Finished();
					} else {
						try{ localStorage.setItem('practice3_done','true'); }catch(err){}
						window.location.href = '../quiz/quiz3.html';
					}
				});

				// Image render pipeline (real-time)
				const img = document.getElementById('source-image');
				const canvas = document.getElementById('photo-canvas');
				const gl = (() => canvas.getContext('webgl2') || canvas.getContext('webgl'))();
				let raf = null;

				function fitCanvas(){
					const rect = canvas.parentElement.getBoundingClientRect();
					canvas.width = Math.round(rect.width);
					canvas.height = Math.round(rect.height);
				}

				// Fallback 2D draw if WebGL unavailable
				const fallbackCtx = !gl ? (canvas.getContext && canvas.getContext('2d')) : null;

				// Image source management for oblique lighting
				function updateImageSource(angle) {
					const img = document.getElementById('source-image');
					if (!img) return;
					
					let newSrc;
					switch(angle) {
						case '30': newSrc = '../level3/30.png'; break;
						case '50': newSrc = '../level3/50.png'; break;
						case '75': newSrc = '../level3/75.png'; break;
						case '90': newSrc = '../level3/90.png'; break;
						default: newSrc = '../assets/blood.png'; break; // Original image for 0/off
					}
					
					if (img.src !== newSrc) {
						img.src = newSrc;
						// Wait for image to load before re-rendering
						img.onload = () => {
							if (gl && programs) {
								// Update WebGL texture
								gl.bindTexture(gl.TEXTURE_2D, srcTex);
								gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
								renderGL(getCurrentValues());
							} else {
								scheduleApply();
							}
						};
					}
				}

				// --- WebGL helpers ---
				function compileShader(source, type){
					const sh = gl.createShader(type);
					gl.shaderSource(sh, source);
					gl.compileShader(sh);
					if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
						console.warn('Shader compile error:', gl.getShaderInfoLog(sh));
						gl.deleteShader(sh);
						return null;
					}
					return sh;
				}

				function createProgram(vsSrc, fsSrc){
					const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
					const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
					const prog = gl.createProgram();
					gl.attachShader(prog, vs); gl.attachShader(prog, fs);
					gl.linkProgram(prog);
					if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
						console.warn('Program link error:', gl.getProgramInfoLog(prog));
						return null;
					}
					return prog;
				}

				function createTextureFromImage(image){
					const tex = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
					gl.bindTexture(gl.TEXTURE_2D, null);
					return tex;
				}

				function createEmptyTexture(w,h){
					const tex = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
					gl.bindTexture(gl.TEXTURE_2D, null);
					return tex;
				}

				function createFBO(tex){
					const fbo = gl.createFramebuffer();
					gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					return fbo;
				}

				// Fullscreen quad
				const vertexSrc = `#version 300 es
				in vec2 a_pos; in vec2 a_uv; out vec2 v_uv; void main(){ v_uv = a_uv; gl_Position = vec4(a_pos,0.0,1.0);} `;

				const quadPos = new Float32Array([
					-1, -1, 0, 0,
					1, -1, 1, 0,
					-1, 1, 0, 1,
					1, 1, 1, 1
				]);

				function setupQuad(){
					const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
					const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
					gl.bufferData(gl.ARRAY_BUFFER, quadPos, gl.STATIC_DRAW);
					return {vao, buf};
				}

				// Simple pass-through fragment shader (WebGL2)
				const passFs = `#version 300 es
				precision mediump float; in vec2 v_uv; uniform sampler2D u_tex; out vec4 outColor; void main(){ outColor = texture(u_tex, v_uv); }`;

				// Blur fragment (separable) - will sample 9 taps with offsets multiplied by radius
				const blurFs = `#version 300 es
				precision mediump float; in vec2 v_uv; uniform sampler2D u_tex; uniform vec2 u_texel; uniform float u_radius; out vec4 outColor;
				void main(){ vec2 uv = v_uv; vec4 c = vec4(0.0);
				float w0 = 0.2270270270;
				float w1 = 0.3162162162;
				float w2 = 0.0702702703;
				vec2 ofs = u_texel * u_radius;
				c += texture(u_tex, uv) * w0;
				c += texture(u_tex, uv + ofs) * w1;
				c += texture(u_tex, uv - ofs) * w1;
				c += texture(u_tex, uv + ofs*2.0) * w2;
				c += texture(u_tex, uv - ofs*2.0) * w2;
				outColor = c;
				}`;

				// Final shader that applies brightness and noise
				const finalFs = `#version 300 es
				precision mediump float; in vec2 v_uv; uniform sampler2D u_tex; uniform float u_brightness; uniform float u_noise; out vec4 outColor;
				// simple rand
				float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
				void main(){ vec4 c = texture(u_tex, v_uv);
				float n = (rand(gl_FragCoord.xy) - 0.5) * u_noise;
				c.rgb = clamp(c.rgb * u_brightness + n, 0.0, 1.0);
				outColor = c;
				}`;

				let programs = null;
				let quad = null;
				let srcTex = null, texA = null, texB = null;
				let fboA = null, fboB = null;

				function initGLResources(){
					if(!gl) return false;
					programs = {
						pass: createProgram(vertexSrc, passFs),
						blur: createProgram(vertexSrc, blurFs),
						final: createProgram(vertexSrc, finalFs)
					};
					quad = setupQuad();
					fitCanvas();
					srcTex = createTextureFromImage(img);
					texA = createEmptyTexture(canvas.width, canvas.height);
					texB = createEmptyTexture(canvas.width, canvas.height);
					fboA = createFBO(texA);
					fboB = createFBO(texB);
					return true;
				}

				function resizeGLTextures(){
					if(!gl) return;
					gl.deleteTexture(texA); gl.deleteTexture(texB); gl.deleteFramebuffer(fboA); gl.deleteFramebuffer(fboB);
					texA = createEmptyTexture(canvas.width, canvas.height);
					texB = createEmptyTexture(canvas.width, canvas.height);
					fboA = createFBO(texA); fboB = createFBO(texB);
				}

				function renderGL(params){
					if(!gl) return;
					fitCanvas();
					gl.viewport(0,0,canvas.width,canvas.height);

					// update source texture if image changed
					gl.bindTexture(gl.TEXTURE_2D, srcTex);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

					// PASS 1: horizontal blur from srcTex -> texA
					gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
					gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
					gl.useProgram(programs.blur);
					gl.bindVertexArray(quad.vao);
					// attributes
					const posLoc = gl.getAttribLocation(programs.blur, 'a_pos');
					const uvLoc = gl.getAttribLocation(programs.blur, 'a_uv');
					gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,16,0);
					gl.enableVertexAttribArray(uvLoc); gl.vertexAttribPointer(uvLoc,2,gl.FLOAT,false,16,8);
					// uniforms
					gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, srcTex);
					gl.uniform1i(gl.getUniformLocation(programs.blur,'u_tex'), 0);
					gl.uniform2f(gl.getUniformLocation(programs.blur,'u_texel'), 1.0/canvas.width, 0.0);
					const radius = Math.max(0.1, (9 - parseFloat(params.aperture || 8)) * 0.6);
					gl.uniform1f(gl.getUniformLocation(programs.blur,'u_radius'), radius);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

					// PASS 2: vertical blur from texA -> texB
					gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
					gl.clear(gl.COLOR_BUFFER_BIT);
					gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA);
					gl.uniform1i(gl.getUniformLocation(programs.blur,'u_tex'), 0);
					gl.uniform2f(gl.getUniformLocation(programs.blur,'u_texel'), 0.0, 1.0/canvas.height);
					gl.uniform1f(gl.getUniformLocation(programs.blur,'u_radius'), radius);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

					// PASS 3: final composite from texB -> screen with brightness & noise
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					gl.useProgram(programs.final);
					gl.bindVertexArray(quad.vao);
					gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texB);
					gl.uniform1i(gl.getUniformLocation(programs.final,'u_tex'), 0);
					// compute brightness from shutter (seconds)/iso/aperture/exposure (stops)
					// Level3 baseline: shutter baseline 1s, ISO baseline 200
					const shutterVal = parseFloat(params.shutter) || 1.0; // shutter in seconds
					const exposureAdj = Math.log2(1.0 / shutterVal);
					const isoVal = parseFloat(params.iso) || 200;
					const isoStops = Math.log2(isoVal / 200);
					const fAperture = parseFloat(params.aperture) || 14.0;
					const apertureStops = 2.0 * Math.log2(16.0 / fAperture);
					const exposureSlider = parseFloat(params.exposure || 0);
					const totalStops = exposureAdj + isoStops + apertureStops + exposureSlider;
					let brightness = Math.pow(2, totalStops);
					gl.uniform1f(gl.getUniformLocation(programs.final,'u_brightness'), brightness);
					const noiseStrength = Math.max(0, (isoVal - 100) / 400);
					gl.uniform1f(gl.getUniformLocation(programs.final,'u_noise'), noiseStrength * 0.06);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}

				function scheduleApply(){ if(raf) cancelAnimationFrame(raf); raf = requestAnimationFrame(()=>{ const vals = getCurrentValues(); if(gl && programs==null){ if(!initGLResources()) { /* fallback handled below */ } } if(gl && programs) { renderGL(vals); } else { // fallback 2D
						const ctx = fallbackCtx; if(ctx){ // draw simple 2D
							fitCanvas(); ctx.clearRect(0,0,canvas.width,canvas.height);
							const iw = img.naturalWidth, ih = img.naturalHeight; const cw = canvas.width, ch = canvas.height; const ir=iw/ih; let dw=cw, dh=ch, dx=0, dy=0; if(ir>cw/ch){ dh=ch; dw=Math.round(ch*ir); dx=Math.round((cw-dw)/2);} else { dw=cw; dh=Math.round(cw/ir); dy=Math.round((ch-dh)/2);} ctx.drawImage(img,dx,dy,dw,dh);
						}
					}
					raf = null; }); }

					// Expose key functions globally so other scripts (modals/helpers)
					// can reliably call them even if loaded in a different scope.
					try{ window.scheduleApply = scheduleApply; }catch(e){}
					try{ window.renderGL = renderGL; }catch(e){}
					try{ window.getCurrentValues = getCurrentValues; }catch(e){}

				function getCurrentValues(){
					// Calculate automatic exposure based on camera settings
					const aperture = parseFloat(document.getElementById('aperture-slider').value);
					const shutter = parseFloat(document.getElementById('shutter-slider').value); // seconds for Level 3
					const iso = parseFloat(document.getElementById('iso-slider').value);
					
					// Calculate exposure value based on aperture, shutter speed, and ISO
					// Using the same baseline as IDEAL_LEVEL3 settings: ISO 200, aperture f/13, shutter 1s
					const apertureStops = Math.log2(aperture * aperture / (13.0 * 13.0)); // relative to f/13 (ideal)
					const shutterStops = Math.log2(shutter / 1); // relative to 1s (ideal)
					const isoStops = Math.log2(iso / 200); // relative to ISO 200 (ideal)
					const calculatedExposure = apertureStops + shutterStops - isoStops;
					
					return {
						aperture: aperture,
						shutter: shutter,
						iso: iso,
						exposure: calculatedExposure,
						oblique: document.getElementById('obliqueBtn') && document.getElementById('obliqueBtn').getAttribute('data-oblique')
					};
				}

				function updateLabels(){
					const ap = document.getElementById('aperture-val'); if(ap) ap.textContent = 'f/' + document.getElementById('aperture-slider').value;
					const sh = document.getElementById('shutter-val'); if(sh) sh.textContent = document.getElementById('shutter-slider').value + ' s';
					const iso = document.getElementById('iso-val'); if(iso) iso.textContent = document.getElementById('iso-slider').value;
					updateExposureIndicator();
				}

				function updateExposureIndicator(){
					const indicator = document.getElementById('exposure-indicator');
					if(!indicator) return;
					
					const values = getCurrentValues();
					const exposure = values.exposure;
					
					// Map exposure value (-3 to +3 range) to position (0% to 100%)
					// Clamp the exposure to the -3 to +3 range for display
					const clampedExposure = Math.max(-3, Math.min(3, exposure));
					const position = ((clampedExposure + 3) / 6) * 100; // Map -3..+3 to 0..100
					
					indicator.style.left = position + '%';
				}

				function updateExposureMeterLevel3(){
					const vals = getCurrentValues();
					const result = evaluateUserLevel3(vals);
					const lbl = document.querySelector('.exposure-label span');
					if(!lbl) return;
					
					// Use the automatic exposure calculation for feedback
					const exposure = vals.exposure; // This is now the calculated exposure
					
					// Provide feedback based on the calculated exposure value
					if(Math.abs(exposure) <= 0.6){ 
						lbl.textContent = 'GOOD EXPOSURE'; 
						lbl.style.color = '#9be89b'; 
					}
					else if(exposure > 0.6){ 
						lbl.textContent = 'OVEREXPOSED'; 
						lbl.style.color = '#ffb86b'; 
					}
					else { 
						lbl.textContent = 'UNDEREXPOSED'; 
						lbl.style.color = '#ff5c5c'; 
					}
					
					// Also update the indicator position
					updateExposureIndicator();
				}

				['aperture-slider','shutter-slider','iso-slider'].forEach(id=>{
					const el = document.getElementById(id);
					if(!el) return;
					el.addEventListener('input', ()=>{
						// update labels first
						updateLabels();
						// apply changes
						scheduleApply();
						// refresh exposure meter text based on current composed settings
						updateExposureMeterLevel3();
					});
				});

				window.addEventListener('resize', ()=>{ fitCanvas(); if(gl) resizeGLTextures(); scheduleApply(); });

				if(!gl){ // immediate fallback draw
					if(fallbackCtx && img.complete){ scheduleApply(); } else if(img){ img.onload = ()=> scheduleApply(); }
				} else {
					img.onload = ()=>{ if(programs==null) initGLResources(); scheduleApply(); };
					if(img.complete){ if(programs==null) initGLResources(); scheduleApply(); }
				}

				updateLabels(); scheduleApply();


				// Level 3 ideal (for close/microscopic evidence with long exposure)
				// Level 3 ranges were set to ISO 200-400, aperture f/12-f/16, shutter 1s
				// We'll use a conservative forensic baseline for this level:
				const IDEAL_LEVEL3 = { iso: 200, aperture: 13, shutter: 1 };

				function stopsForSettingsLevel3({iso, aperture, shutter, exposure}){
					// shutter is seconds (1s), map to denominator baseline 1/125 for stops math
					const shutterVal = parseFloat(shutter) || 1; // seconds
					// convert seconds to denominator for stops comparison: denom = 1 / shutterVal
					const denom = shutterVal > 0 ? (1.0 / shutterVal) : 125.0;
					const shutterStops = Math.log2(125 / denom);
					const isoVal = parseFloat(iso) || 200;
					const isoStops = Math.log2(isoVal / 200);
					const f = parseFloat(aperture) || 13;
					const apStops = 2.0 * Math.log2(8.0 / f);
					const exposureSlider = parseFloat(exposure || 0);
					return { totalStops: shutterStops + isoStops + apStops + exposureSlider, shutterStops, isoStops, apStops };
				}

				function evaluateUserLevel3(user){
					const u = stopsForSettingsLevel3(user);
					const ideal = stopsForSettingsLevel3({ iso: IDEAL_LEVEL3.iso, aperture: IDEAL_LEVEL3.aperture, shutter: IDEAL_LEVEL3.shutter, exposure:0 });
					const delta = u.totalStops - ideal.totalStops;
					
					// Check margin of error for individual settings
					const apertureInRange = Math.abs(user.aperture - IDEAL_LEVEL3.aperture) <= 1;
					const shutterInRange = Math.abs(user.shutter - IDEAL_LEVEL3.shutter) <= 100;
					const isoInRange = Math.abs(user.iso - IDEAL_LEVEL3.iso) <= 100;
					const withinMarginOfError = apertureInRange && shutterInRange && isoInRange;
					
					return { 
						delta, 
						userStops: u, 
						idealStops: ideal, 
						withinTolerance: Math.abs(delta) <= 0.25,
						apertureInRange,
						shutterInRange,
						isoInRange,
						withinMarginOfError
					};
				}

				// Submit uses stops-based evaluation for Level 3
				document.getElementById('submitBtn').addEventListener('click', ()=>{
					const user = getCurrentValues();
					if(gl && programs) renderGL(user); else scheduleApply();
					const result = evaluateUserLevel3(user);
					openResultModal({ ok: result.withinTolerance, user, ideal: IDEAL_LEVEL3, result });
					if(!result.withinTolerance){
						const diff = result.delta;
						const msg = diff > 0 ? 'Image likely overexposed by ~' + diff.toFixed(2) + ' stops.' : 'Image likely underexposed by ~' + Math.abs(diff).toFixed(2) + ' stops.';
						flMessage.textContent = msg + ' Adjust ISO/aperture/shutter.';
					}
				});

				// Reset restores defaults and original image
				document.getElementById('resetBtn').addEventListener('click', ()=>{
					document.getElementById('iso-slider').value = 600;
					document.getElementById('aperture-slider').value = 8;
					document.getElementById('shutter-slider').value = 125;
					updateLabels(); if(gl && programs) { renderGL(getCurrentValues()); } else { scheduleApply(); }
					// reset oblique lighting state and image
					const obliqueBtn = document.getElementById('obliqueBtn'); 
					if(obliqueBtn){ 
						obliqueBtn.classList.remove('active'); 
						obliqueBtn.setAttribute('data-oblique','0'); 
						const s = obliqueBtn.querySelector('span'); 
						if(s) s.textContent = 'Off'; 
					}
					// Reset image to original
					updateImageSource('0');
					closeResultModal();
				});

				// Oblique lighting button and modal wiring
				const obliqueBtn = document.getElementById('obliqueBtn');
				const obliqueModal = document.getElementById('oblique-modal');
				
				if(obliqueBtn && obliqueModal){
					// Open oblique lighting modal
					obliqueBtn.addEventListener('click', ()=>{
						obliqueModal.setAttribute('aria-hidden','false');
					});
					
					// Close oblique lighting modal
					document.getElementById('oblique-close').addEventListener('click', ()=>{
						obliqueModal.setAttribute('aria-hidden','true');
					});
					
					// Handle angle selection
					const angleButtons = obliqueModal.querySelectorAll('.oblique-angle-btn');
					angleButtons.forEach(btn => {
						btn.addEventListener('click', ()=>{
							const angle = btn.getAttribute('data-angle');
							
							// Update button states
							angleButtons.forEach(b => b.classList.remove('active'));
							btn.classList.add('active');
							
							// Update main oblique button
							obliqueBtn.setAttribute('data-oblique', angle);
							const label = obliqueBtn.querySelector('span');
							if(label) {
								if(angle === '0') {
									label.textContent = 'Off';
									obliqueBtn.classList.remove('active');
								} else {
									label.textContent = angle + '°';
									obliqueBtn.classList.add('active');
								}
							}
							
							// Update image source based on angle
							updateImageSource(angle);
							
							// Close modal
							obliqueModal.setAttribute('aria-hidden','true');
						});
					});
					
					// Set initial state for angle 0 (Off)
					const offBtn = obliqueModal.querySelector('[data-angle="0"]');
					if(offBtn) offBtn.classList.add('active');
				}
			});

		// Prevent portrait mode scrolling
		window.addEventListener('orientationchange', function() {
			if(window.orientation === 0 || window.orientation === 180) {
				document.body.style.overflow = 'hidden';
			} else {
				document.body.style.overflow = '';
			}
		});
	</script>
</head>
    
	<body>
	<!-- modal markup inserted near body start for layering -->
		<div id="fl-result-modal" class="fl-modal-overlay" aria-hidden="true">
		<div class="fl-modal" role="dialog" aria-modal="true">
			<div class="fl-icon" id="fl-icon">
				<!-- icon injected via class -->
			</div>
			<h2 id="fl-heading">Success!</h2>
			<p id="fl-message">Perfect! The details are clearly documented</p>

			<div class="fl-settings">
				<div class="fl-col">
					<div class="fl-col-title">Your Settings</div>
					<div class="fl-list">
						<p id="fl-iso-user">ISO: 400</p>
						<p id="fl-ap-user">F/5.6</p>
						<p id="fl-sh-user">1/60s</p>
					</div>
				</div>
				<div class="fl-col">
					<div class="fl-col-title">Ideal Settings</div>
					<div class="fl-list">
						<p id="fl-iso-ideal">ISO: 200</p>
						<p id="fl-ap-ideal">F/8</p>
						<p id="fl-sh-ideal">1/125s</p>
					</div>
				</div>
			</div>

				<!-- Global helper to ensure oblique lighting reliably updates UI and triggers rendering -->
				<script>
					function updateObliqueUI(){
						// trigger existing input handlers by dispatching an input event on a slider
						const ex = document.getElementById('exposure-slider');
						if(ex){ const ev = new Event('input', { bubbles:true, cancelable:true }); ex.dispatchEvent(ev); }
					}
				</script>

			<div class="fl-actions">
				<button id="fl-try" class="fl-btn fl-ghost">Try Again</button>
				<button id="fl-next" class="fl-btn fl-primary">Next Level</button>
			</div>
		</div>
	</div>

	<!-- Oblique Lighting Modal -->
	<div id="oblique-modal" class="fl-modal-overlay" aria-hidden="true">
		<div class="fl-modal" role="dialog" aria-modal="true" aria-labelledby="obliqueHeading">
			<h2 id="obliqueHeading">Oblique Lighting Angle</h2>
			<p>Select the angle for oblique lighting effect:</p>
			
			<div style="display: flex; flex-direction: column; gap: 12px; margin: 20px 0;">
				<button class="oblique-angle-btn" data-angle="0" style="background: #2b2b2b; color: #fff; border: 1px solid #555; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600;">
					Off (No Oblique Lighting)
				</button>
				<button class="oblique-angle-btn" data-angle="30" style="background: #2b2b2b; color: #fff; border: 1px solid #555; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600;">
					30° Oblique Lighting
				</button>
				<button class="oblique-angle-btn" data-angle="50" style="background: #2b2b2b; color: #fff; border: 1px solid #555; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600;">
					50° Oblique Lighting
				</button>
				<button class="oblique-angle-btn" data-angle="75" style="background: #2b2b2b; color: #fff; border: 1px solid #555; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600;">
					75° Oblique Lighting
				</button>
				<button class="oblique-angle-btn" data-angle="90" style="background: #2b2b2b; color: #fff; border: 1px solid #555; padding: 12px; border-radius: 8px; cursor: pointer; font-weight: 600;">
					90° Oblique Lighting
				</button>
			</div>

			<div class="fl-actions">
				<button id="oblique-close" class="fl-btn fl-ghost">Close</button>
			</div>
		</div>
	</div>

	<script>
		// Modal control helpers
		const modal = document.getElementById('fl-result-modal');
		const flIcon = document.getElementById('fl-icon');
		const flHeading = document.getElementById('fl-heading');
		const flMessage = document.getElementById('fl-message');
		const flIsoUser = document.getElementById('fl-iso-user');
		const flApUser = document.getElementById('fl-ap-user');
		const flShUser = document.getElementById('fl-sh-user');

		function openResultModal({ok, user, ideal, result}){
			modal.setAttribute('aria-hidden','false');
			
			// Get the next level button
			const nextBtn = document.getElementById('fl-next');
			
			// Prioritize margin of error check for icon and message
			if(result && result.withinMarginOfError) {
				// All settings within margin - show success
				flIcon.className = 'fl-icon success';
				flIcon.innerHTML = '<i class="fa-solid fa-circle-check" aria-hidden="true"></i>';
				flHeading.textContent = 'Success!';
				flMessage.textContent = 'Perfect! The details are clearly documented.';
			} else {
				// Settings outside margin - show try again
				flIcon.className = 'fl-icon fail';
				flIcon.innerHTML = '<i class="fa-solid fa-circle-xmark" aria-hidden="true"></i>';
				flHeading.textContent = 'Try Again';
				
				if(result && !result.withinMarginOfError) {
					// Add specific feedback about what's out of range
					let errorMsg = 'Settings outside acceptable range: ';
					let errors = [];
					if(!result.apertureInRange) errors.push('aperture (±1.0)');
					if(!result.shutterInRange) errors.push('shutter speed (±100)');
					if(!result.isoInRange) errors.push('ISO (±100)');
					errorMsg += errors.join(', ');
					flMessage.textContent = errorMsg;
				} else {
					flMessage.textContent = 'The image is not correctly exposed. Adjust and try again.';
				}
			}
			
			// Enable/disable next button based on margin of error
			if(result && !result.withinMarginOfError) {
				nextBtn.style.opacity = '0.5';
				nextBtn.style.pointerEvents = 'none';
				nextBtn.style.cursor = 'not-allowed';
				nextBtn.setAttribute('disabled', 'true');
			} else {
				nextBtn.style.opacity = '1';
				nextBtn.style.pointerEvents = 'auto';
				nextBtn.style.cursor = 'pointer';
				nextBtn.removeAttribute('disabled');
			}
			
			// Show/hide ideal settings based on margin of error
			const settingsContainer = document.querySelector('.fl-settings');
			const idealCol = settingsContainer.querySelector('.fl-col:last-child'); // Second column (Ideal Settings)
			
			if(result && !result.withinMarginOfError) {
				// Hide ideal settings when outside margin of error
				if(idealCol) idealCol.style.display = 'none';
				// Center the user settings column
				const userCol = settingsContainer.querySelector('.fl-col:first-child');
				if(userCol) userCol.style.margin = '0 auto';
			} else {
				// Show ideal settings when within margin of error
				if(idealCol) idealCol.style.display = 'block';
				// Reset user settings column alignment
				const userCol = settingsContainer.querySelector('.fl-col:first-child');
				if(userCol) userCol.style.margin = '';
			}
			
			flIsoUser.textContent = 'ISO: ' + user.iso;
			flApUser.textContent = 'Aperture: f/' + user.aperture;
			flShUser.textContent = 'Shutter: 1/' + user.shutter + 's';
			if(ideal){
				const flIsoIdeal = document.getElementById('fl-iso-ideal');
				const flApIdeal = document.getElementById('fl-ap-ideal');
				const flShIdeal = document.getElementById('fl-sh-ideal');
				if(flIsoIdeal) flIsoIdeal.textContent = 'ISO: ' + (ideal.iso || '200');
				if(flApIdeal) flApIdeal.textContent = 'Aperture: f/' + (ideal.aperture || '16');
				if(flShIdeal) flShIdeal.textContent = 'Shutter: ' + (ideal.shutter ? (ideal.shutter + 's') : '1s');
			}
		}
		function closeResultModal(){ modal.setAttribute('aria-hidden','true'); }

		document.addEventListener('DOMContentLoaded', ()=>{
			// Image render pipeline
			const img = document.getElementById('source-image');
			const canvas = document.getElementById('photo-canvas');
			const ctx = canvas.getContext && canvas.getContext('2d');
			let originalImageData = null;

			function fitCanvas(){
				const rect = canvas.parentElement.getBoundingClientRect();
				canvas.width = Math.round(rect.width);
				canvas.height = Math.round(rect.height);
			}

			function drawOriginal(){
				if(!ctx) return;
				fitCanvas();
				ctx.clearRect(0,0,canvas.width,canvas.height);
				// draw the source image covering the canvas (cover)
				const iw = img.naturalWidth, ih = img.naturalHeight;
				const cw = canvas.width, ch = canvas.height;
				const ir = iw/ih, cr = cw/ch;
				let dw= cw, dh = ch, dx = 0, dy = 0;
				if(ir > cr){ // image wider -> fit height
					dh = ch; dw = ih * ir * (ch/ih); // keep aspect
					dw = Math.round(ch * ir);
					dx = Math.round((cw - dw)/2);
				} else {
					dw = cw; dh = Math.round(cw / ir);
					dy = Math.round((ch - dh)/2);
				}
				ctx.drawImage(img, dx, dy, dw, dh);
				try{ originalImageData = ctx.getImageData(0,0,canvas.width,canvas.height); }catch(e){ originalImageData = null; }
			}

			// very small gaussian blur approximation using canvas filter when available
				function applyEffects({aperture, shutter, iso, oblique, exposure}){
				if(!ctx) return;
				fitCanvas();
				// Start from original
				if(originalImageData){ ctx.putImageData(originalImageData,0,0); }
				// compute blur from aperture: in Level3 aperture range is f/12 - f/16, smaller aperture = less blur
				const f = parseFloat(aperture || 14.0);
				const blurAmt = Math.max(0, (14.0 / f - 1.0) * 2.5);

				// compute exposure from shutter (seconds), ISO baseline 200, aperture relative to f/16
				const shutterVal = parseFloat(shutter) || 1.0; // seconds
				const exposureAdj = Math.log2(1.0 / shutterVal);
				const isoVal = parseFloat(iso) || 200;
				const isoStops = Math.log2(isoVal / 200 || 1);
				const apertureStops = 2.0 * Math.log2(16.0 / f);
				const exposureSlider = parseFloat(exposure || 0);
				const totalStops = exposureAdj + isoStops + apertureStops + exposureSlider;

				// Use canvas filter when available for blur and brightness
				const supportsFilter = 'filter' in ctx;
				if(supportsFilter){
					ctx.filter = `blur(${blurAmt}px) brightness(${Math.pow(2, totalStops)})`;
					if(originalImageData){ ctx.putImageData(originalImageData,0,0); } else { drawOriginal(); }
					ctx.filter = 'none';
				} else {
					const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
					const d = imgd.data;
					const bright = Math.pow(2, totalStops);
					for(let i=0;i<d.length;i+=4){ d[i] = Math.min(255, d[i]*bright); d[i+1] = Math.min(255, d[i+1]*bright); d[i+2] = Math.min(255, d[i+2]*bright); }
					ctx.putImageData(imgd,0,0);
				}

				// Add noise for ISO (Level3 low ISO range -> small noise)
				const noiseStrength = Math.max(0, (isoVal - 100) / 400);
				if(noiseStrength > 0){
					const imgd2 = ctx.getImageData(0,0,canvas.width,canvas.height);
					const d2 = imgd2.data;
					for(let i=0;i<d2.length;i+=4){
						const rnd = (Math.random()-0.5) * 255 * noiseStrength * 0.25;
						d2[i] = Math.max(0, Math.min(255, d2[i] + rnd));
						d2[i+1] = Math.max(0, Math.min(255, d2[i+1] + rnd));
						d2[i+2] = Math.max(0, Math.min(255, d2[i+2] + rnd));
					}
					ctx.putImageData(imgd2,0,0);
				}

				// Apply oblique lighting overlay if provided
				if(oblique){
					const deg = parseFloat(oblique || 10);
					const rad = deg * Math.PI / 180.0;
					const dx = Math.cos(rad), dy = Math.sin(rad) * 0.6;
					const g = ctx.createLinearGradient(canvas.width*(0.5-dx*0.6), canvas.height*(0.5-dy*0.6), canvas.width*(0.5+dx*0.6), canvas.height*(0.5+dy*0.6));
					const alpha = Math.min(0.35, 0.025 * deg);
					g.addColorStop(0, `rgba(255,240,220,${alpha})`);
					g.addColorStop(0.5, `rgba(255,240,220,${alpha*0.4})`);
					g.addColorStop(1, `rgba(255,240,220,0)`);
					ctx.globalCompositeOperation = 'overlay';
					ctx.fillStyle = g;
					ctx.fillRect(0,0,canvas.width,canvas.height);
					ctx.globalCompositeOperation = 'source-over';
				}
			}

			// initialize image
				if(img.complete){ drawOriginal(); } else { img.onload = ()=>{ drawOriginal(); }; }

				// For the 2D fallback, avoid duplicating submit/reset/oblique logic. The
				// primary submit/reset wiring above handles evaluation and modal state.
				if(typeof drawOriginal === 'function' && document.getElementById('resetBtn')){
					document.getElementById('resetBtn').addEventListener('click', ()=>{
						document.getElementById('iso-slider').value = 200;
						document.getElementById('aperture-slider').value = 14;
						document.getElementById('shutter-slider').value = 1;
						// Reset oblique and image
						const obliqueBtn = document.getElementById('obliqueBtn'); 
						if(obliqueBtn){ 
							obliqueBtn.classList.remove('active'); 
							obliqueBtn.setAttribute('data-oblique','0'); 
							const s = obliqueBtn.querySelector('span'); 
							if(s) s.textContent = 'Off'; 
						}
						updateImageSource('0');
						updateLabels(); drawOriginal(); closeResultModal();
					});
				}
				document.getElementById('fl-try').addEventListener('click', ()=>{ closeResultModal(); });
		});
	</script>
	<div class="top-bar">
		<button class="back-btn" onclick="window.location.href='../index.html'" aria-label="Back">
			<svg viewBox="0 0 32 32"><path d="M20.7 25.3a1 1 0 0 1-1.4 0l-8-8a1 1 0 0 1 0-1.4l8-8a1 1 0 1 1 1.4 1.4L13.42 16l7.3 7.3a1 1 0 0 1 0 1.4z"/></svg>
		</button>
		<div class="level-title">Level 3: Blood</div>
		<div class="task-box">Task: Take a properly exposed photo of the scene with the evidence marker included.</div>
	</div>
	<div id="main-content">
			<div class="flex-row">
				<div class="flex-left">
					<div class="photo-box">
						<img id="source-image" src="../assets/blood.png" alt="Gun Evidence" style="display:none" />
						<canvas id="photo-canvas" aria-label="Photo preview"></canvas>
					</div>
					<div class="exposure-label">Exposure Meter: <span>GOOD EXPOSURE</span></div>
					<div class="exposure-slider">
						<div class="slider-track">
							<div class="meter-container">
								<div id="exposure-indicator" class="meter-indicator" style="left: 50%;"></div>
							</div>
						</div>
						<div class="ticks" aria-hidden="true">
							<span style="left:0%"></span><label style="left:0%">-3</label>
							<span style="left:16.66%"></span><label style="left:16.66%">-2</label>
							<span style="left:33.33%"></span><label style="left:33.33%">-1</label>
							<span style="left:50%"></span><label style="left:50%">0</label>
							<span style="left:66.66%"></span><label style="left:66.66%">1</label>
							<span style="left:83.33%"></span><label style="left:83.33%">2</label>
							<span style="left:100%"></span><label style="left:100%">3</label>
						</div>
					</div>
				</div>
				<div class="flex-right">
					<!-- Camera Modes -->
					<div class="modes" role="tablist" aria-label="Camera Modes" style="gap:6px; padding:2px; margin-top: -5px;">
						<button class="mode active" role="tab" aria-selected="true" data-mode="M">Manual (M)</button>
						<button class="mode" role="tab" aria-selected="false" data-mode="Tv">Shutter Priority (Tv)</button>
						<button class="mode" role="tab" aria-selected="false" data-mode="Av">Aperture Priority (Av)</button>
					</div>
					<!-- Header: title on the left, oblique lighting button on the right -->
					<div class="controls-title" style="display:flex; justify-content:space-between; align-items:center; margin-top: -12px;">
						<span>Camera Controls</span>
						<div style="display:flex; align-items:center; gap:8px;">
							<div class="control-label" style="margin:0; font-size:12px;">Oblique Lighting</div>
							<button id="obliqueBtn" class="oblique-toggle" role="button" aria-label="Oblique lighting options" data-oblique="0">
								<span style="margin-left:6px;">Off</span>
								<div class="three-dots" aria-hidden="true">
									<span></span><span></span><span></span>
								</div>
							</button>
						</div>
					</div>
					<div class="controls-inner">
						<div class="control-group" >
							<div class="control-label">&#9673; APERTURE: <span id="aperture-val">12</span></div>
							<!-- Level 3 uses f/12 - f/16 -->
							<input type="range" min="12" max="16" value="12" step="0.5" class="control-slider" id="aperture-slider">
							<div class="ticks" aria-hidden="true">
								<span style="left:0%"></span><label style="left:0%">f/12</label>
								<span style="left:33%"></span><label style="left:33%">f/13</label>
								<span style="left:66%"></span><label style="left:66%">f/14</label>
								<span style="left:100%"></span><label style="left:100%">f/16</label>
							</div>
						</div>
						<div class="control-group">
							<div class="control-label">&#128336; SHUTTER SPEED: <span id="shutter-val">1 s</span></div>
							<!-- Level 3 requires long exposure 1 second; provide a hidden input to carry the value and a display --><input type="hidden" id="shutter-slider" value="1">
							<div class="ticks" aria-hidden="true">
								<span style="left:0%"></span><label style="left:0%">1 s</label>
							</div>
						</div>
						<div class="control-group">
							<div class="control-label">&#9728; ISO: <span id="iso-val">200</span></div>
							<!-- Level 3 ISO 200 - 400 -->
							<input type="range" min="200" max="400" value="200" step="50" class="control-slider" id="iso-slider">
							<div class="ticks" aria-hidden="true">
								<span style="left:0%"></span><label style="left:0%">200</label>
								<span style="left:50%"></span><label style="left:50%">300</label>
								<span style="left:100%"></span><label style="left:100%">400</label>
							</div>
						</div>
						<div class="controls-btns">
							<button class="btn reset" id="resetBtn">Reset</button>
							<button class="btn submit" id="submitBtn">Submit</button>
						</div>
					</div>
				</div>
			</div>
        </div>
    </div>
	<!-- Camera Modes behavior (mode-based control enabling) -->
	<script>
		document.addEventListener('DOMContentLoaded', function(){
			const container = document.querySelector('.modes');
			if(!container) return;
			const buttons = Array.from(container.querySelectorAll('.mode'));

			function setDisabled(el, disabled){ if(!el) return; el.disabled = !!disabled; const grp = el.closest('.control-group'); if(grp){ grp.classList.toggle('control-disabled', !!disabled); } }
			function applyModeToControls(mode){
				const ap = document.getElementById('aperture-slider');
				const sh = document.getElementById('shutter-slider'); // hidden 1s
				const iso = document.getElementById('iso-slider');
				const ex = document.getElementById('exposure-slider');
				if(mode === 'M'){
					[ap, /*sh,*/ iso, ex].forEach(el => setDisabled(el, false)); // shutter fixed but keep others enabled
				}else if(mode === 'Tv'){
					// only shutter would be enabled, but it's fixed; disable others to match rule
					[ap, iso, ex].forEach(el => setDisabled(el, true));
				}else if(mode === 'Av'){
					setDisabled(ap, false);
					[iso, ex].forEach(el => setDisabled(el, true));
				}
				try{ if(typeof scheduleApply === 'function') scheduleApply(); }catch(e){}
			}

			buttons.forEach(btn => {
				btn.addEventListener('click', () => {
					buttons.forEach(b => { b.classList.remove('active'); b.setAttribute('aria-selected','false'); });
					btn.classList.add('active');
					btn.setAttribute('aria-selected','true');
					const mode = btn.getAttribute('data-mode') || 'M';
					applyModeToControls(mode);
				});
			});

			// initialize to current active or default Manual
			const initial = (container.querySelector('.mode.active')?.getAttribute('data-mode')) || 'M';
			applyModeToControls(initial);
		});
	</script>
</body>
</html>