
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
	<title>Level 4: fingerprint</title>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;400&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
	<style>
		:root { --topbar-h: 64px; --gutter: 16px; }
		html, body {
			height: 100vh;
			margin: 0;
			padding: 0;
			background: #18181a;
			color: #fff;
			font-family: 'Inter', 'Montserrat', Arial, sans-serif;
			width: 100vw;
			overflow: hidden; /* prevent scrolling */
		}
		body {
			height: 100vh;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: flex-start;
			box-sizing: border-box;
		}
		@media only screen and (orientation: portrait) {
			body::before {
				content: 'Please rotate your device';
				position: fixed;
				z-index: 9999;
				top: 0; left: 0; right: 0; bottom: 0;
				background: #18181a;
				color: #fff;
				font-size: 2rem;
				display: flex;
				align-items: center;
				justify-content: center;
				text-align: center;
			}
			#main-content { display: none !important; }
		}
		/* Layout: left image, right controls */
		.layout, .flex-row {
			display: flex;
			flex-direction: row;
			gap: 32px;
			align-items: stretch;
			justify-content: center;
			width: calc(100vw - (var(--gutter) * 2));
			max-width: 1240px;
			margin: 0 auto;
			padding: 8px var(--gutter) 16px var(--gutter);
			box-sizing: border-box;
			height: calc(100vh - var(--topbar-h) - 24px);
			overflow: hidden;
		}
		.left,
		.flex-left {
			flex: 1.2;
			display: flex;
			flex-direction: column;
			align-items: center;
			min-width: 0;
			height: 100%;
			justify-content: space-between;
			padding-bottom: 8px;
		}
		.right,
		.flex-right {
			flex: 1;
			background: #232326;
			border-radius: 20px;
			border: 2px solid #b3b3b733;
			padding: 12px 12px 12px 12px;
			box-sizing: border-box;
			min-width: 220px;
			max-width: 420px;
			display: flex;
			flex-direction: column;
			gap: 20px;
			height: 100%;
			overflow: hidden;
		}
		.back-btn {
			position: absolute;
			top: 32px;
			left: 0; /* will be repositioned inside top-bar */
			background: #232326;
			border-radius: 14px;
			width: 56px;
			height: 56px;
			display: flex;
			align-items: center;
			justify-content: center;
			border: none;
			box-shadow: 0 2px 8px #0002;
			cursor: pointer;
			z-index: 2;
		}
		.back-btn svg {
			width: 28px;
			height: 28px;
			fill: #b3b3b7;
		}
		.level-title {
			font-family: 'Montserrat', Arial, sans-serif;
			font-size: 20px;
			font-weight: 700;
			text-align: left;
			margin: 0 0 0 0;
			margin-left: 96px;
			margin-top: 0;
			margin-bottom: 0;
			letter-spacing: 1px;
			position: relative;
			top: 18px;
		}
		.task-box {
			background: #232326;
			color: #fff;
			border-radius: 20px;
			padding: 16px 32px;
			font-size: 12px;
			font-weight: 400;
			margin: 0 0 0 24px;
			max-width: 620px;
			box-sizing: border-box;
			border: 2px solid #b3b3b733;
			position: relative;
			z-index: 1;
		}
		.top-bar {
			display: flex;
			align-items: center;
			gap: 18px;
			width: 100%;
			max-width: 1240px;
			margin: 12px auto 0 auto;
			padding: 0 var(--gutter);
			box-sizing: border-box;
			height: var(--topbar-h);
		}
		/* When top-bar exists, make back-btn static inside it */
		.top-bar .back-btn { position: static; }
		.photo-box {
			width: 100%;
			max-width: 720px;
			flex: 1 1 auto;
			background: #111;
			border-radius: 20px;
			border: 2px solid #b3b3b733;
			overflow: hidden;
			margin-bottom: 18px;
			display: flex;
			align-items: center;
			justify-content: center;
			position: relative;
		}
		.photo-box img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			display: block;
		}
		.exposure-label {
			text-align: center;
			font-size: 1.2rem;
			font-weight: 500;
			margin-bottom: 8px;
			margin-top: 8px;
		}
		.exposure-label span {
			font-weight: 700;
		}
		.exposure-slider {
			width: 100%;
			margin: 0 auto 0 auto;
			display: flex;
			flex-direction: column;
			align-items: center;
		}
		.slider-track {
			width: 95%;
			margin: 0 auto;
			position: relative;
			height: 36px;
			display: flex;
			align-items: center;
		}
		/* ticks under sliders */
		.ticks {
			display: block;
			width: 95%;
			margin: -5px auto 0 auto;
			height: 10px;
			position: relative;
		}
		.ticks span {
			position: absolute;
			bottom: 2px;
			width: 2px;
			height: 6px; /* shorter tick */
			background: #666;
			transform: translateX(-50%);
		}
		.ticks label {
			position: absolute;
			bottom: -12px; /* closer label */
			transform: translateX(-50%);
			font-size: 10px;
			color: #b3b3b7;
		}
		.slider {
			width: 100%;
			accent-color: #ff3b3f;
			height: 4px;
			margin: 0;
		}
		.slider-labels {
			width: 95%;
			display: flex;
			justify-content: space-between;
			font-size: 1.1rem;
			color: #b3b3b7;
			margin-top: 2px;
			margin-bottom: 0;
		}
		.controls-title {
			font-family: 'Montserrat', Arial, sans-serif;
			font-size: 13px;
			font-weight: 700;
			margin-bottom: 6px;
			margin-top: 0;
			display: flex;
			align-items: center;
			gap: 8px;
		}
		/* Slightly tighten the top of controls area */
		.controls-inner { padding-top: 1px; }
		.control-group {
			margin-bottom: 20px;
            
		}
		.control-label {
			font-size: 12px;
			font-weight: 500;
			margin-bottom: 6px;
			display: flex;
			align-items: center;
			gap: 6px;
		}
		.control-slider {
			width: 100%;
			accent-color: #ff3b3f;
			margin: 0 0 6px 0;
			height: 28px;
		}
		.control-range-labels {
			display: flex;
			justify-content: space-between;
			font-size: 9px;
			color: #b3b3b7;
			margin-bottom: 0;
		}

		.reset-btn, .btn.reset {
			background: none;
			color: #fff;
			border: 1px solid #b3b3b7;
			border-radius: 10px;
			font-size: 0.95rem;
			font-weight: 500;
			padding: 8px 14px;
			cursor: pointer;
			transition: background 0.2s, color 0.2s;
		}
		.reset-btn:hover, .btn.reset:hover {
			background: #232326;
			color: #ff3b3f;
		}
		.submit-btn, .btn.submit {
			flex:1;
			background: #ff3b3f;
			color: #fff;
			border: none;
			border-radius: 10px;
			font-size: 0.95rem;
			font-weight: 700;
			padding: 8px 12px;
			cursor: pointer;
			box-shadow: 0 2px 8px #ff3b3f22;
			transition: background 0.2s;
		}
		.submit-btn:hover, .btn.submit:hover {
			background: #e22e32;
		}

		/* Make the right column scroll internally if needed */
		.flex-right .controls-inner { overflow:auto; max-height: calc(100% - 50px); padding-right: 6px; }
		@media (max-width: 1100px) {
			.layout { flex-direction: column; align-items: center; gap: 12px; height: auto; }
			.task-box { position: static; margin: 12px 0; max-width: 100vw; width: 100%; }
			.level-title { margin-left: 0; text-align: left; top: 0; }
			.top-bar { padding: 0 12px; }
		}
		@media (max-width: 700px) {
			.layout { padding: 8px 6px 0 6px; gap: 12px; }
			.photo-box { width: 100%; height: 40vw; min-height: 140px; max-width: 100%; }
			.right { min-width: 0; max-width: 100vw; padding: 12px 8px; }
			.top-bar { padding: 0 10px; }
		}

		/* Result modal styles */
		.fl-modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0,0,0,0.6);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 9998;
		}
		.fl-modal-overlay[aria-hidden="false"] { display: flex; }
		.fl-modal {
			width: calc(100% - 64px);
			max-width: 420px;
			background: #0f0f10;
			border-radius: 16px;
			padding: 18px;
			box-shadow: 0 8px 30px rgba(0,0,0,0.6);
			color: #fff;
			border: 1px solid #2b2b2b;
			text-align: center;
		}
		.fl-icon {
			width: 96px;
			height: 96px;
			margin: 6px auto 10px auto;
			border-radius: 50%;
			background-size: cover;
			background-position: center;
			display: flex;
			align-items: center;
			justify-content: center;
			box-shadow: inset 0 -6px 18px rgba(0,0,0,0.25);
		}
		.fl-icon.success { background-color: #1e5; }
		.fl-icon.fail { background-color: #ff6b6b; }
		.fl-modal h2 { margin: 8px 0 6px 0; font-size: 20px; }
		.fl-modal p { margin: 0 0 12px 0; color: #d1d1d1; }
		.fl-settings { display:flex; gap: 10px; justify-content: center; margin: 10px 0 14px 0; }
		.fl-col { min-width: 120px; }
		.fl-col-title { font-weight:700; font-size: 12px; color: #fff; margin-bottom: 6px; }
		.fl-list p { margin: 4px 0; font-size: 13px; color:#dcdcdc; }
		.fl-actions { display:flex; gap:10px; justify-content: center; }
		.fl-btn { padding: 10px 12px; border-radius: 10px; font-weight:700; cursor:pointer; border: none; }
		.fl-ghost { background: transparent; border: 1px solid #555; color: #fff; }
		.fl-primary { background: #ff3b3f; color: #fff; }
	</style>
	<style>
        /* Canvas photo styling */
        #photo-canvas { width: 100%; height: 100%; display: block; }
    </style>
		<style>
			/* Buttons under settings */
			.controls-btns { display:flex; gap:12px; justify-content: space-between; margin-top: 6px; }
			.btn { flex:1; padding: 10px 12px; border-radius: 12px; border: none; font-weight: 600; cursor: pointer; }
			.btn.reset { background: #2b2b2b; color: #fff; border: 1px solid #555; }
			.btn.submit { background: #e22e32; color: #fff; border: 1px solid #555; }
			.btn:active { transform: translateY(1px); }
		</style>

		<!-- Camera Modes styles -->
		<style>
			.modes { display: flex; gap: 10px; background: #1b1b1d; border: 1px solid #2b2b2b; border-radius: 14px; padding: 8px; margin-bottom: 10px; }
			.modes .mode { flex: 1; background: #2a2a2e; color: #ddd; border: 1px solid #2f2f2f; border-radius: 12px; padding: 10px 12px; font-weight: 700; cursor: pointer; text-align: center; }
			.modes .mode.active { background: #d6d6da; color:#1b1b1d; border-color:#bdbdc2; box-shadow:0 6px 18px rgba(0,0,0,0.12); }
		</style>

		<!-- Disabled controls styles for Tv/Av modes -->
		<style>
			.control-group.control-disabled { opacity: 0.45; filter: grayscale(40%); }
			.control-group.control-disabled .control-slider:disabled { cursor: not-allowed; }
			.control-slider:disabled { opacity: 0.8; cursor: not-allowed; }
		</style>

			<style>
				/* Flash toggle visual styles */
				.flash-toggle { display:flex; align-items:center; gap:8px; justify-content:flex-start; padding:10px 12px; border-radius:12px; background:#171718; border:1px solid #2b2b2b; color:#ddd; font-weight:700; cursor:pointer; width:100%; transition: background 160ms, color 160ms, box-shadow 160ms; }
				.flash-toggle .indicator { width:14px; height:14px; border-radius:50%; background:#4a4a4a; box-shadow:inset 0 -2px 4px rgba(0,0,0,0.5); border:1px solid #2f2f2f; transition: background 160ms, transform 160ms; }
				.flash-toggle .label { margin-left:6px; font-size:0.95rem; color:inherit; }
				/* ON = green (enabled), OFF = red (disabled) */
				.flash-toggle.on { background: linear-gradient(90deg,#6fe27a,#2fc24a); color:#082308; box-shadow:0 6px 18px rgba(47,194,74,0.12); }
				.flash-toggle.on .indicator { background: #063a08; transform: scale(1.05); box-shadow:0 2px 8px rgba(0,0,0,0.12); border-color: #0b5a0d; }
				.flash-toggle.off { background: linear-gradient(90deg,#ff9b9b,#ff4f4f); color:#330606; box-shadow:0 6px 18px rgba(255,79,79,0.10); }
				.flash-toggle.off .indicator { background: #330606; border-color: #5a0b0b; }
			</style>

			<style>
				/* Lighting option buttons */
				.lighting-list { display:flex; }
				.lighting-option {
					background: #171718;
					color: #ddd;
					border: 1px solid #2b2b2b;
					padding: 8px 10px;
					border-radius: 8px;
					font-weight:600;
					cursor: pointer;
				}
				.lighting-option[aria-pressed="true"] {
					background: linear-gradient(90deg,#2b7eeb,#2ad1d1);
					color: #04121a;
					box-shadow: 0 6px 16px rgba(42,209,209,0.12);
				}
			</style>
	    <script type="module" src="../algo/firebase.js"></script>
	    <script src="../algo/algo.js"></script>
	<script>
			// Simple toast for submit feedback
			function showToast(msg) {
				let t = document.getElementById('fl-toast');
				if(!t) {
					t = document.createElement('div');
					t.id = 'fl-toast';
					t.style.position = 'absolute';
					t.style.bottom = '18px';
					t.style.left = '50%';
					t.style.transform = 'translateX(-50%)';
					t.style.background = 'rgba(0,0,0,0.8)';
					t.style.color = '#fff';
					t.style.padding = '10px 14px';
					t.style.borderRadius = '12px';
					t.style.zIndex = 9999;
					document.body.appendChild(t);
				}
				t.textContent = msg;
				setTimeout(()=>{ if(t) t.remove(); }, 1800);
			}

			// Global helper: simulate a camera flash overlay and trigger rendering
			function flashOverlay(duration = 220){
				const canvas = document.getElementById('photo-canvas');
				if(!canvas) return;
				let ov = document.getElementById('flash-overlay');
				if(!ov){
					ov = document.createElement('div');
					ov.id = 'flash-overlay';
					ov.style.position = 'absolute';
					ov.style.pointerEvents = 'none';
					ov.style.background = '#fff';
					ov.style.opacity = '0';
					ov.style.transition = `opacity ${duration}ms ease-out`;
					document.body.appendChild(ov);
				}
				const rect = canvas.getBoundingClientRect();
				ov.style.left = rect.left + 'px';
				ov.style.top = rect.top + 'px';
				ov.style.width = rect.width + 'px';
				ov.style.height = rect.height + 'px';
				ov.style.zIndex = 9997;
				// trigger flash
				requestAnimationFrame(()=>{ ov.style.opacity = '0.95'; setTimeout(()=>{ ov.style.opacity = '0'; }, Math.max(80, duration - 80)); });
				// remove element after transition
				setTimeout(()=>{ try{ ov.remove(); }catch(e){} }, duration + 160);
			}

			function simulateFlash(){
				// quick overlay for user feedback
				flashOverlay(220);
				// trigger a re-render so any shader/2D pipeline updates (if present) run.
				try{ updateCanvasFilter(); }catch(e){}
				try{ if(typeof scheduleApply === 'function') scheduleApply(); }catch(e){}
			}

			// Reset and Submit handlers
			document.addEventListener('DOMContentLoaded', ()=>{
				// wire modal action buttons
				document.getElementById('fl-try').addEventListener('click', ()=>{ closeResultModal(); });
				document.getElementById('fl-next').addEventListener('click', (e)=>{
					try{ e.preventDefault(); }catch(_){ }
					if(window.ForensicFlow && typeof ForensicFlow.onPractice4Finished === 'function'){
						ForensicFlow.onPractice4Finished();
					} else {
						try{ localStorage.setItem('practice4_done','true'); }catch(err){}
						window.location.href = '../quiz/quiz4.html';
					}
				});

				// Image render pipeline (real-time)
				const img = document.getElementById('source-image');
				const canvas = document.getElementById('photo-canvas');
				const gl = (() => canvas.getContext('webgl2') || canvas.getContext('webgl'))();
				let raf = null;

				function fitCanvas(){
					const rect = canvas.parentElement.getBoundingClientRect();
					canvas.width = Math.round(rect.width);
					canvas.height = Math.round(rect.height);
				}

				// Shared lighting + flash state (global so other handlers can use it)
				window._lightingType = window._lightingType || 'none';
				window._persistentFlash = window._persistentFlash || false;

				// Lighting buttons will swap the source image from ../level4/ instead of applying filters.
				function updateCanvasFilter(){
					const canvas = document.getElementById('photo-canvas'); if(!canvas) return;
					// only persistent flash is applied via CSS filter now
					const flashPart = window._persistentFlash ? ' brightness(4)' : '';
					canvas.style.filter = flashPart.trim();
				}

				// expose helpers globally
				window.updateCanvasFilter = updateCanvasFilter;

				// Fallback 2D draw if WebGL unavailable
				const fallbackCtx = !gl ? (canvas.getContext && canvas.getContext('2d')) : null;

				// --- WebGL helpers ---
				function compileShader(source, type){
					const sh = gl.createShader(type);
					gl.shaderSource(sh, source);
					gl.compileShader(sh);
					if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
						console.warn('Shader compile error:', gl.getShaderInfoLog(sh));
						gl.deleteShader(sh);
						return null;
					}
					return sh;
				}

				function createProgram(vsSrc, fsSrc){
					const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
					const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
					const prog = gl.createProgram();
					gl.attachShader(prog, vs); gl.attachShader(prog, fs);
					gl.linkProgram(prog);
					if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
						console.warn('Program link error:', gl.getProgramInfoLog(prog));
						return null;
					}
					return prog;
				}

				function createTextureFromImage(image){
					const tex = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
					gl.bindTexture(gl.TEXTURE_2D, null);
					return tex;
				}

				function createEmptyTexture(w,h){
					const tex = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, tex);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
					gl.bindTexture(gl.TEXTURE_2D, null);
					return tex;
				}

				function createFBO(tex){
					const fbo = gl.createFramebuffer();
					gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					return fbo;
				}

				// Fullscreen quad
				const vertexSrc = `#version 300 es
				in vec2 a_pos; in vec2 a_uv; out vec2 v_uv; void main(){ v_uv = a_uv; gl_Position = vec4(a_pos,0.0,1.0);} `;

				const quadPos = new Float32Array([
					-1, -1, 0, 0,
					1, -1, 1, 0,
					-1, 1, 0, 1,
					1, 1, 1, 1
				]);

				function setupQuad(){
					const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
					const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
					gl.bufferData(gl.ARRAY_BUFFER, quadPos, gl.STATIC_DRAW);
					return {vao, buf};
				}

				// Simple pass-through fragment shader (WebGL2)
				const passFs = `#version 300 es
				precision mediump float; in vec2 v_uv; uniform sampler2D u_tex; out vec4 outColor; void main(){ outColor = texture(u_tex, v_uv); }`;

				// Blur fragment (separable) - will sample 9 taps with offsets multiplied by radius
				const blurFs = `#version 300 es
				precision mediump float; in vec2 v_uv; uniform sampler2D u_tex; uniform vec2 u_texel; uniform float u_radius; out vec4 outColor;
				void main(){ vec2 uv = v_uv; vec4 c = vec4(0.0);
				float w0 = 0.2270270270;
				float w1 = 0.3162162162;
				float w2 = 0.0702702703;
				vec2 ofs = u_texel * u_radius;
				c += texture(u_tex, uv) * w0;
				c += texture(u_tex, uv + ofs) * w1;
				c += texture(u_tex, uv - ofs) * w1;
				c += texture(u_tex, uv + ofs*2.0) * w2;
				c += texture(u_tex, uv - ofs*2.0) * w2;
				outColor = c;
				}`;

				// Final shader that applies brightness and noise
				const finalFs = `#version 300 es
				precision mediump float; in vec2 v_uv; uniform sampler2D u_tex; uniform float u_brightness; uniform float u_noise; out vec4 outColor;
				// simple rand
				float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
				void main(){ vec4 c = texture(u_tex, v_uv);
				float n = (rand(gl_FragCoord.xy) - 0.5) * u_noise;
				c.rgb = clamp(c.rgb * u_brightness + n, 0.0, 1.0);
				outColor = c;
				}`;

				let programs = null;
				let quad = null;
				let srcTex = null, texA = null, texB = null;
				let fboA = null, fboB = null;

				function initGLResources(){
					if(!gl) return false;
					programs = {
						pass: createProgram(vertexSrc, passFs),
						blur: createProgram(vertexSrc, blurFs),
						final: createProgram(vertexSrc, finalFs)
					};
					quad = setupQuad();
					fitCanvas();
					srcTex = createTextureFromImage(img);
					texA = createEmptyTexture(canvas.width, canvas.height);
					texB = createEmptyTexture(canvas.width, canvas.height);
					fboA = createFBO(texA);
					fboB = createFBO(texB);
					return true;
				}

				// expose renderGL so simulateFlash can call it
				window.renderGL = function(params){ try{ renderGL(params); }catch(e){} };

				function resizeGLTextures(){
					if(!gl) return;
					gl.deleteTexture(texA); gl.deleteTexture(texB); gl.deleteFramebuffer(fboA); gl.deleteFramebuffer(fboB);
					texA = createEmptyTexture(canvas.width, canvas.height);
					texB = createEmptyTexture(canvas.width, canvas.height);
					fboA = createFBO(texA); fboB = createFBO(texB);
				}
				// make available globally so other scripts (modal) can call when source image changes
				window.resizeGLTextures = resizeGLTextures;

				function renderGL(params){
					if(!gl) return;
					fitCanvas();
					gl.viewport(0,0,canvas.width,canvas.height);

					// update source texture if image changed
					gl.bindTexture(gl.TEXTURE_2D, srcTex);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

					// PASS 1: horizontal blur from srcTex -> texA
					gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
					gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
					gl.useProgram(programs.blur);
					gl.bindVertexArray(quad.vao);
					// attributes
					const posLoc = gl.getAttribLocation(programs.blur, 'a_pos');
					const uvLoc = gl.getAttribLocation(programs.blur, 'a_uv');
					gl.enableVertexAttribArray(posLoc); gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,16,0);
					gl.enableVertexAttribArray(uvLoc); gl.vertexAttribPointer(uvLoc,2,gl.FLOAT,false,16,8);
					// uniforms
					gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, srcTex);
					gl.uniform1i(gl.getUniformLocation(programs.blur,'u_tex'), 0);
					gl.uniform2f(gl.getUniformLocation(programs.blur,'u_texel'), 1.0/canvas.width, 0.0);
					const radius = Math.max(0.1, (9 - parseFloat(params.aperture || 8)) * 0.6);
					gl.uniform1f(gl.getUniformLocation(programs.blur,'u_radius'), radius);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

					// PASS 2: vertical blur from texA -> texB
					gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
					gl.clear(gl.COLOR_BUFFER_BIT);
					gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA);
					gl.uniform1i(gl.getUniformLocation(programs.blur,'u_tex'), 0);
					gl.uniform2f(gl.getUniformLocation(programs.blur,'u_texel'), 0.0, 1.0/canvas.height);
					gl.uniform1f(gl.getUniformLocation(programs.blur,'u_radius'), radius);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

					// PASS 3: final composite from texB -> screen with brightness & noise
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					gl.useProgram(programs.final);
					gl.bindVertexArray(quad.vao);
					gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texB);
					gl.uniform1i(gl.getUniformLocation(programs.final,'u_tex'), 0);
					// compute brightness from shutter/iso/exposure (and flash)
					const shutterVal = parseFloat(params.shutter) || 125;
					const exposureAdj = Math.log2(125 / shutterVal);
					const isoVal = parseFloat(params.iso) || 400;
					const isoStops = Math.log2(isoVal / 400);
					const exposureSlider = parseFloat(params.exposure || 0);
					const totalStops = exposureAdj + isoStops + exposureSlider;
					let brightness = Math.pow(2, totalStops);
					if(params.flash){ // flash adds roughly +2 stops (bright quick burst)
						brightness *= 4.0;
					}
					gl.uniform1f(gl.getUniformLocation(programs.final,'u_brightness'), brightness);
					const noiseStrength = Math.max(0, (isoVal - 200) / 1600);
					gl.uniform1f(gl.getUniformLocation(programs.final,'u_noise'), noiseStrength * 0.06);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				}

				function scheduleApply(){ if(raf) cancelAnimationFrame(raf); raf = requestAnimationFrame(()=>{ const vals = getCurrentValues(); if(gl && programs==null){ if(!initGLResources()) { /* fallback handled below */ } } if(gl && programs) { renderGL(vals); } else { // fallback 2D
						const ctx = fallbackCtx; if(ctx){ // draw simple 2D
							fitCanvas(); ctx.clearRect(0,0,canvas.width,canvas.height);
							const iw = img.naturalWidth, ih = img.naturalHeight; const cw = canvas.width, ch = canvas.height; const ir=iw/ih; let dw=cw, dh=ch, dx=0, dy=0; if(ir>cw/ch){ dh=ch; dw=Math.round(ch*ir); dx=Math.round((cw-dw)/2);} else { dw=cw; dh=Math.round(cw/ir); dy=Math.round((ch-dh)/2);} ctx.drawImage(img,dx,dy,dw,dh);
						}
					}
					raf = null; }); }
				// expose scheduleApply globally so modal handlers can re-render after swapping source image
				window.scheduleApply = scheduleApply;

				function getCurrentValues(){
					return {
						aperture: document.getElementById('aperture-slider').value,
						shutter: document.getElementById('shutter-slider').value,
						iso: document.getElementById('iso-slider').value,
						exposure: document.getElementById('exposure-slider').value,
						flash: document.getElementById('flashToggle') && document.getElementById('flashToggle').classList.contains('on')
					};
				}

				function updateLabels(){
					const ap = document.getElementById('aperture-val'); if(ap) ap.textContent = 'f/' + document.getElementById('aperture-slider').value;
					const sh = document.getElementById('shutter-val'); if(sh) sh.textContent = '1/' + document.getElementById('shutter-slider').value;
					const iso = document.getElementById('iso-val'); if(iso) iso.textContent = document.getElementById('iso-slider').value;
				}

				// Level 4 desired exposure and stops-based meter
				const IDEAL_LEVEL4 = { iso: 400, aperture: 10, shutter: 125 };
				function stopsForSettingsLevel4({iso, aperture, shutter, exposure}){
					const shutterVal = parseFloat(shutter) || 125;
					const shutterStops = Math.log2(125 / shutterVal);
					const isoVal = parseFloat(iso) || 400;
					const isoStops = Math.log2(isoVal / 400);
					const f = parseFloat(aperture) || 10;
					const apStops = 2.0 * Math.log2(10 / f);
					const exposureSlider = parseFloat(exposure || 0);
					return { totalStops: shutterStops + isoStops + apStops + exposureSlider, shutterStops, isoStops, apStops };
				}
				function evaluateUserLevel4(user){
					const u = stopsForSettingsLevel4(user);
					const ideal = stopsForSettingsLevel4({ iso: IDEAL_LEVEL4.iso, aperture: IDEAL_LEVEL4.aperture, shutter: IDEAL_LEVEL4.shutter, exposure: 0 });
					const delta = u.totalStops - ideal.totalStops;
					return { delta, withinTolerance: Math.abs(delta) <= 0.6 };
				}
				function computeDesiredExposureLevel4(){
					const iso = parseFloat(document.getElementById('iso-slider').value);
					const aperture = parseFloat(document.getElementById('aperture-slider').value);
					const shutter = parseFloat(document.getElementById('shutter-slider').value);
					const cur = stopsForSettingsLevel4({ iso, aperture, shutter, exposure: 0 });
					const ideal = stopsForSettingsLevel4({ iso: IDEAL_LEVEL4.iso, aperture: IDEAL_LEVEL4.aperture, shutter: IDEAL_LEVEL4.shutter, exposure: 0 });
					let needed = ideal.totalStops - cur.totalStops;
					const exEl = document.getElementById('exposure-slider');
					if(exEl){ const min = parseFloat(exEl.getAttribute('min') || -3); const max = parseFloat(exEl.getAttribute('max') || 3);
						if(needed < min) needed = min; if(needed > max) needed = max; needed = Math.round(needed * 10)/10; }
					return needed;
				}
				function updateExposureMeterLevel4(){
					const vals = getCurrentValues();
					const r = evaluateUserLevel4(vals);
					const lbl = document.querySelector('.exposure-label span'); if(!lbl) return;
					if(Math.abs(r.delta) <= 0.6){ lbl.textContent = 'GOOD EXPOSURE'; lbl.style.color = '#9be89b'; }
					else if(r.delta > 0){ lbl.textContent = 'OVEREXPOSED'; lbl.style.color = '#ffb86b'; }
					else { lbl.textContent = 'UNDEREXPOSED'; lbl.style.color = '#ff5c5c'; }
				}

				['aperture-slider','shutter-slider','iso-slider','exposure-slider'].forEach(id=>{
					const el = document.getElementById(id);
					if(!el) return;
					el.addEventListener('input', ()=>{
						updateLabels();
						if(id !== 'exposure-slider'){
							const desired = computeDesiredExposureLevel4();
							const exEl = document.getElementById('exposure-slider'); if(exEl) exEl.value = desired;
						}
						scheduleApply();
						updateExposureMeterLevel4();
					});
				});

				window.addEventListener('resize', ()=>{ fitCanvas(); if(gl) resizeGLTextures(); scheduleApply(); });

				if(!gl){ // immediate fallback draw
					if(fallbackCtx && img.complete){ scheduleApply(); } else if(img){ img.onload = ()=> scheduleApply(); }
				} else {
					img.onload = ()=>{ if(programs==null) initGLResources(); scheduleApply(); };
					if(img.complete){ if(programs==null) initGLResources(); scheduleApply(); }
				}

				updateLabels(); scheduleApply();

				// Submit opens modal but image updates in real-time already
				document.getElementById('submitBtn').addEventListener('click', ()=>{
					const user = getCurrentValues();
					if(gl && programs) renderGL(user); else scheduleApply();
					const ev = parseFloat(document.getElementById('exposure-slider').value);
					const ok = Math.abs(ev) <= 0.6;
					openResultModal({ok, user, ideal: {iso:200, aperture:8, shutter:125}});
				});

				// Reset restores defaults and original image
				document.getElementById('resetBtn').addEventListener('click', ()=>{
					document.getElementById('iso-slider').value = 600;
					document.getElementById('aperture-slider').value = 8;
					document.getElementById('shutter-slider').value = 125;
					document.getElementById('exposure-slider').value = 0;
					updateLabels(); if(gl && programs) { renderGL(getCurrentValues()); } else { scheduleApply(); }
					// reset flash visual state
					const fbtnR = document.getElementById('flashToggle'); if(fbtnR){ fbtnR.classList.remove('on'); fbtnR.classList.add('off'); fbtnR.setAttribute('aria-checked','false'); const s = fbtnR.querySelector('span'); if(s) s.textContent = 'Off'; }
					// clear lighting selection and canvas filters
					const modal = document.getElementById('moreOptionsModal');
					if(modal){
						const btns = modal.querySelectorAll('.lighting-option');
						btns.forEach(b=>{ b.setAttribute('aria-pressed','false'); });
						const def = modal.querySelector('.lighting-option[data-type="none"]'); if(def) def.setAttribute('aria-pressed','true');
						modal.style.display = 'none'; modal.setAttribute('aria-hidden','true');
						const moreBtn = document.getElementById('moreOptionsBtn'); if(moreBtn) moreBtn.setAttribute('aria-expanded','false');
					}
					// clear persistent flash and update composed filter
					window._persistentFlash = false;
					const canvas = document.getElementById('photo-canvas'); updateCanvasFilter();
					closeResultModal();
				});

				// Flash toggle wiring (GL pipeline)
				const flashBtn = document.getElementById('flashToggle');
				if(flashBtn){
					// ensure initial visual state
					if(!flashBtn.classList.contains('on')){ flashBtn.classList.add('off'); flashBtn.setAttribute('aria-checked','false'); const s0 = flashBtn.querySelector('span'); if(s0) s0.textContent = 'Off'; }
					flashBtn.addEventListener('click', ()=>{
						const isOn = flashBtn.classList.toggle('on');
						flashBtn.classList.toggle('off', !isOn);
						flashBtn.setAttribute('aria-checked', isOn ? 'true' : 'false');
						const s = flashBtn.querySelector('span'); if(s) s.textContent = isOn ? 'On' : 'Off';
						// persistent flash state
						window._persistentFlash = !!isOn;
						if(isOn){
							// clear any active lighting selection when flash is enabled
							window._lightingType = 'none';
							const modal = document.getElementById('moreOptionsModal');
							if(modal){
								const btns = modal.querySelectorAll('.lighting-option'); btns.forEach(b=>b.setAttribute('aria-pressed','false'));
								const def = modal.querySelector('.lighting-option[data-type="none"]'); if(def) def.setAttribute('aria-pressed','true');
							}
							// also ensure modal flash toggle (if present) reflects state
							const fbm = document.getElementById('flashToggleModal'); if(fbm){ fbm.classList.add('on'); fbm.classList.remove('off'); fbm.setAttribute('aria-checked','true'); const sm = fbm.querySelector('span'); if(sm) sm.textContent='On'; }
						}
						updateCanvasFilter();
						// trigger render
						scheduleApply();
						// initial flash overlay feedback when enabling
						if(isOn){ try{ flashOverlay(220); }catch(e){} }
					});
				}
			});

			// Exposure slider live update
			(function(){
				const ex = document.getElementById('exposure-slider');
				if(!ex) return;
				function refresh(){ try{ updateExposureMeterLevel4(); }catch(e){} }
				refresh();
				ex.addEventListener('input', ()=>{ refresh(); });
			})();

		// Prevent portrait mode scrolling
		window.addEventListener('orientationchange', function() {
			if(window.orientation === 0 || window.orientation === 180) {
				document.body.style.overflow = 'hidden';
			} else {
				document.body.style.overflow = '';
			}
		});
	</script>
		<script>
			// Lighting options wiring: now uses the More Options modal
			document.addEventListener('DOMContentLoaded', function(){
				const modal = document.getElementById('moreOptionsModal');
				const moreBtn = document.getElementById('moreOptionsBtn');
				const closeBtn = document.getElementById('moreCloseBtn');
				const lightBtns = modal ? modal.querySelectorAll('.lighting-option') : [];
				const canvas = document.getElementById('photo-canvas');
				const flashModalBtn = document.getElementById('flashToggleModal');
				const flashMainBtn = document.getElementById('flashToggle');

				function openModal(){ if(!modal) return; modal.style.display = 'flex'; modal.setAttribute('aria-hidden','false'); if(moreBtn) moreBtn.setAttribute('aria-expanded','true'); }
				function closeModal(){ if(!modal) return; modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); if(moreBtn) moreBtn.setAttribute('aria-expanded','false'); }



				if(moreBtn){ moreBtn.addEventListener('click', function(){ openModal(); }); }
				if(closeBtn){ closeBtn.addEventListener('click', function(){ closeModal(); }); }

				function applyLighting(type){
					// Map lighting types to ready-made images in ../level4/
					const imgEl = document.getElementById('source-image');
					let src = '../assets/fingerprint.png'; // default
						switch(type){
						case 'diffused': src = '../level4/A. DiffusedLightingEffect.png'; break;
						case 'oblique': src = '../level4/B. ObliqueLightingEffect.png'; break;
						case 'transmitted': src = '../level4/C. TransmittedLightingEffect.png'; break;
						case 'ultraviolet': src = '../level4/D. UltraVioletLightingEffect.png'; break;
						case 'none':
					default: src = '../assets/fingerprint.png'; break;
					}
					// If flash is currently enabled, disable it when applying a lighting preset
					if(window._persistentFlash){
						window._persistentFlash = false;
						// update main and modal flash buttons if present
						const fb = document.getElementById('flashToggle');
						const fbm = document.getElementById('flashToggleModal');
						if(fb){ fb.classList.remove('on'); fb.classList.add('off'); fb.setAttribute('aria-checked','false'); const s = fb.querySelector('span'); if(s) s.textContent = 'Off'; }
						if(fbm){ fbm.classList.remove('on'); fbm.classList.add('off'); fbm.setAttribute('aria-checked','false'); const sm = fbm.querySelector('span'); if(sm) sm.textContent = 'Off'; }
						updateCanvasFilter();
					}
					window._lightingType = type || 'none';
					if(imgEl){
						imgEl.src = src;
						// ensure the image loads then render. Handle cached images by triggering
						// resize and scheduleApply immediately if already complete.
						imgEl.onload = function(){
							try{ if(typeof resizeGLTextures === 'function') resizeGLTextures(); }catch(e){}
							try{ if(typeof scheduleApply === 'function') scheduleApply(); }catch(e){}
						};
						// Also trigger immediately in case the image is cached and .onload won't fire
						if(imgEl.complete){
							try{ if(window.resizeGLTextures) window.resizeGLTextures(); }catch(e){}
							try{ if(window.scheduleApply) window.scheduleApply(); }catch(e){}
						}
					}
					updateCanvasFilter();
				}

				if(lightBtns && lightBtns.length){
					lightBtns.forEach(btn=>{
						btn.addEventListener('click', function(e){
							const type = this.getAttribute('data-type') || 'none';
							lightBtns.forEach(b=>{ b.setAttribute('aria-pressed','false'); });
							this.setAttribute('aria-pressed','true');
							applyLighting(type);
						});
					});
					const def = modal.querySelector('.lighting-option[data-type="none"]'); if(def) def.setAttribute('aria-pressed','true');
				}

				// Flash toggle in modal should keep main flash UI in sync
				if(flashModalBtn){
					flashModalBtn.addEventListener('click', function(){
						// toggle visual state
						const isOn = flashModalBtn.classList.toggle('on');
						flashModalBtn.classList.toggle('off', !isOn);
						flashModalBtn.setAttribute('aria-checked', isOn ? 'true' : 'false');
						const lbl = flashModalBtn.querySelector('span'); if(lbl) lbl.textContent = isOn ? 'On' : 'Off';
						// mirror to main flash button if exists
						if(flashMainBtn){ flashMainBtn.className = flashModalBtn.className; const lm = flashMainBtn.querySelector('span'); if(lm) lm.textContent = flashModalBtn.querySelector('span').textContent; flashMainBtn.setAttribute('aria-checked', isOn ? 'true' : 'false'); }
						// persistent flash: update flag and filters
						window._persistentFlash = !!isOn;
						if(isOn){
							// clear any active lighting
							window._lightingType = 'none';
							if(modal){ const btns = modal.querySelectorAll('.lighting-option'); btns.forEach(b=>b.setAttribute('aria-pressed','false')); const def = modal.querySelector('.lighting-option[data-type="none"]'); if(def) def.setAttribute('aria-pressed','true'); }
						}
						updateCanvasFilter();
						// trigger render
						const ex = document.getElementById('exposure-slider'); if(ex) ex.dispatchEvent(new Event('input',{bubbles:true}));
						// initial flash overlay for feedback
						if(isOn){ try{ flashOverlay(220); }catch(e){} }
					});
				}

				// When modal opens, copy main flash state into modal toggle
				if(flashMainBtn && flashModalBtn){
					if(flashMainBtn.classList.contains('on')){ flashModalBtn.classList.add('on'); flashModalBtn.classList.remove('off'); flashModalBtn.setAttribute('aria-checked','true'); const s = flashModalBtn.querySelector('span'); if(s) s.textContent = 'On'; }
				}

				// close modal when clicking overlay
				if(modal){ modal.addEventListener('click', function(e){ if(e.target === modal){ closeModal(); } }); }
			});
		</script>
</head>
    
	<body>
	<!-- modal markup inserted near body start for layering -->
		<div id="fl-result-modal" class="fl-modal-overlay" aria-hidden="true">
		<div class="fl-modal" role="dialog" aria-modal="true">
			<div class="fl-icon" id="fl-icon">
				<!-- icon injected via class -->
						</div>
						<!-- More options opens a modal (handled later) -->
			<h2 id="fl-heading">Success!</h2>
			<p id="fl-message">Perfect! The details are clearly documented</p>

			<div class="fl-settings">
				<div class="fl-col">
					<div class="fl-col-title">Your Settings</div>
					<div class="fl-list">
						<p id="fl-iso-user">ISO: 400</p>
						<p id="fl-ap-user">F/5.6</p>
						<p id="fl-sh-user">1/60s</p>
					</div>
				</div>
				<div class="fl-col">
					<div class="fl-col-title">Ideal Settings</div>
					<div class="fl-list">
						<p id="fl-iso-ideal">ISO: 200</p>
						<p id="fl-ap-ideal">F/8</p>
						<p id="fl-sh-ideal">1/125s</p>
					</div>
				</div>
			</div>

				<!-- Global helper to ensure flash toggle reliably updates UI and triggers rendering -->
				<script>
					function toggleFlashUI(e){
						const btn = document.getElementById('flashToggle');
						if(!btn) return;
						const isOn = btn.classList.toggle('on');
						btn.classList.toggle('off', !isOn);
						btn.setAttribute('aria-checked', isOn ? 'true' : 'false');
						const lbl = btn.querySelector('span'); if(lbl) lbl.textContent = isOn ? 'On' : 'Off';
						// also update indicator styling immediately
						const ind = btn.querySelector('.indicator'); if(ind){ /* visual handled by CSS classes */ }
						// trigger existing input handlers by dispatching an input event on a slider
						const ex = document.getElementById('exposure-slider');
						if(ex){ const ev = new Event('input', { bubbles:true, cancelable:true }); ex.dispatchEvent(ev); }
					}
				</script>

			<div class="fl-actions">
				<button id="fl-try" class="fl-btn fl-ghost">Try Again</button>
				<button id="fl-next" class="fl-btn fl-primary">Next Level</button>
			</div>
		</div>
	</div>

	<!-- More Options Modal -->
	<div id="moreOptionsModal" class="fl-modal-overlay" aria-hidden="true">
		<div class="fl-modal" role="dialog" aria-modal="true" aria-labelledby="moreOptionsHeading">
			<h2 id="moreOptionsHeading">More Options</h2>
			<div style="margin:8px 0 12px 0; color:#d1d1d1;">Additional controls for lighting and flash.</div>
			<div style="display:flex; flex-direction:column; gap:12px;">
				<div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
					<div class="control-label" style="margin:0; font-size:12px; color:#ddd;">Flash</div>
					<button id="flashToggleModal" class="flash-toggle" role="switch" aria-checked="false">
						<div class="indicator" aria-hidden="true"></div>
						<span style="margin-left:6px;">Off</span>
					</button>
				</div>
				<div>
					<div class="control-label" style="margin:0 0 6px 0; font-size:12px; color:#ddd;">Lighting</div>
					<div class="lighting-list" role="list" style="display:flex; gap:8px; flex-wrap:wrap;">
						<button class="lighting-option" data-type="none" aria-pressed="false" title="None" style="flex:1; min-width:76px;">Normal</button>
						<button class="lighting-option" data-type="diffused" aria-pressed="false" title="Diffused Lighting" style="flex:1; min-width:76px;">Diffused</button>
						<button class="lighting-option" data-type="oblique" aria-pressed="false" title="Oblique Lighting" style="flex:1; min-width:76px;">Oblique</button>
						<button class="lighting-option" data-type="transmitted" aria-pressed="false" title="Transmitted Lighting" style="flex:1; min-width:76px;">Transmitted</button>
						<button class="lighting-option" data-type="ultraviolet" aria-pressed="false" title="Ultraviolet Lighting" style="flex:1; min-width:76px;">Ultraviolet</button>
					</div>
				</div>
				<div style="display:flex; gap:8px; justify-content:flex-end; margin-top:6px;">
					<button id="moreCloseBtn" class="fl-btn fl-ghost">Close</button>
				</div>
			</div>
		</div>
	</div>

	<script>
		// Modal control helpers
		const modal = document.getElementById('fl-result-modal');
		const flIcon = document.getElementById('fl-icon');
		const flHeading = document.getElementById('fl-heading');
		const flMessage = document.getElementById('fl-message');
		const flIsoUser = document.getElementById('fl-iso-user');
		const flApUser = document.getElementById('fl-ap-user');
		const flShUser = document.getElementById('fl-sh-user');

		function openResultModal({ok, user, ideal}){
			modal.setAttribute('aria-hidden','false');
			if(ok){
				flIcon.className = 'fl-icon success';
				flHeading.textContent = 'Success!';
				flMessage.textContent = 'Perfect! The details are clearly documented.';
			} else {
				flIcon.className = 'fl-icon fail';
				flHeading.textContent = 'Try Again';
				flMessage.textContent = 'The image is not correctly exposed. Adjust and try again.';
			}
			flIsoUser.textContent = 'ISO: ' + user.iso;
			flApUser.textContent = 'Aperture: f/' + user.aperture;
			flShUser.textContent = 'Shutter: 1/' + user.shutter + 's';
			// TODO: populate ideal values if provided
		}
		function closeResultModal(){ modal.setAttribute('aria-hidden','true'); }

		document.addEventListener('DOMContentLoaded', ()=>{
			// Image render pipeline
			const img = document.getElementById('source-image');
			const canvas = document.getElementById('photo-canvas');
			const ctx = canvas.getContext && canvas.getContext('2d');
			let originalImageData = null;

			function fitCanvas(){
				const rect = canvas.parentElement.getBoundingClientRect();
				canvas.width = Math.round(rect.width);
				canvas.height = Math.round(rect.height);
			}

			function drawOriginal(){
				if(!ctx) return;
				fitCanvas();
				ctx.clearRect(0,0,canvas.width,canvas.height);
				// draw the source image covering the canvas (cover)
				const iw = img.naturalWidth, ih = img.naturalHeight;
				const cw = canvas.width, ch = canvas.height;
				const ir = iw/ih, cr = cw/ch;
				let dw= cw, dh = ch, dx = 0, dy = 0;
				if(ir > cr){ // image wider -> fit height
					dh = ch; dw = ih * ir * (ch/ih); // keep aspect
					dw = Math.round(ch * ir);
					dx = Math.round((cw - dw)/2);
				} else {
					dw = cw; dh = Math.round(cw / ir);
					dy = Math.round((ch - dh)/2);
				}
				ctx.drawImage(img, dx, dy, dw, dh);
				try{ originalImageData = ctx.getImageData(0,0,canvas.width,canvas.height); }catch(e){ originalImageData = null; }
			}

			// very small gaussian blur approximation using canvas filter when available
				function applyEffects({aperture, shutter, iso, flash}){
				if(!ctx) return;
				fitCanvas();
				// Start from original
				if(originalImageData){ ctx.putImageData(originalImageData,0,0); }
				// compute blur from aperture: smaller aperture (higher f-number) = more depth -> less blur.
				// our aperture slider uses numeric f-values where larger = smaller opening. We'll invert: lower f -> more blur
				const f = parseFloat(aperture);
				const blurAmt = Math.max(0, (10 - f) * 1.2); // rough mapping

				// compute exposure change from shutter: faster shutter (higher denominator) -> darker image
				const shutterVal = parseFloat(shutter); // shutter slider gives denominator like 125
				const exposureAdj = Math.log2(125 / shutterVal || 1); // relative stops to baseline 125

				// compute ISO effect (noise + slight brightness); baseline 400
				const isoVal = parseFloat(iso);
				const isoStops = Math.log2(isoVal / 400 || 1);

					// Use canvas filter when available for blur and brightness
				const supportsFilter = 'filter' in ctx;
				if(supportsFilter){
						let brightnessFactor = Math.pow(2, exposureAdj + isoStops);
						if(flash) brightnessFactor *= 4.0; // flash adds roughly +2 stops
						ctx.filter = `blur(${blurAmt}px) brightness(${brightnessFactor})`;
					// redraw original through filter
					if(originalImageData){ ctx.putImageData(originalImageData,0,0); } else { drawOriginal(); }
					ctx.filter = 'none';
				} else {
					// fallback: adjust brightness by reading pixels
					const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
						const d = imgd.data;
						let bright = Math.pow(2, exposureAdj + isoStops);
						if(flash) bright *= 4.0;
					for(let i=0;i<d.length;i+=4){ d[i] = Math.min(255, d[i]*bright); d[i+1] = Math.min(255, d[i+1]*bright); d[i+2] = Math.min(255, d[i+2]*bright); }
					ctx.putImageData(imgd,0,0);
				}

				// Add noise for ISO
				const noiseStrength = Math.max(0, (isoVal - 200) / 1600); // 400 -> small, 800 -> higher
				if(noiseStrength > 0){
					const imgd2 = ctx.getImageData(0,0,canvas.width,canvas.height);
					const d2 = imgd2.data;
					for(let i=0;i<d2.length;i+=4){
						const rnd = (Math.random()-0.5) * 255 * noiseStrength * 0.4; // subtle
						d2[i] = Math.max(0, Math.min(255, d2[i] + rnd));
						d2[i+1] = Math.max(0, Math.min(255, d2[i+1] + rnd));
						d2[i+2] = Math.max(0, Math.min(255, d2[i+2] + rnd));
					}
					ctx.putImageData(imgd2,0,0);
				}
			}

			// initialize image
				if(img.complete){ drawOriginal(); } else { img.onload = ()=>{ drawOriginal(); }; }

				// expose applyEffects for external triggers
				window.applyEffects = applyEffects;

				// wire submit to apply effects and open result modal (2D fallback)
				document.getElementById('submitBtn').addEventListener('click', ()=>{
					const user = {
						iso: document.getElementById('iso-slider').value,
						aperture: document.getElementById('aperture-slider').value,
						shutter: document.getElementById('shutter-slider').value,
						flash: document.getElementById('flashToggle') && document.getElementById('flashToggle').classList.contains('on')
					};
					applyEffects(user);
					const ev2 = parseFloat(document.getElementById('exposure-slider').value);
					const ok2 = Math.abs(ev2) <= 0.6;
					openResultModal({ok: ok2, user, ideal: {iso:200, aperture:8, shutter:125}});
				});

				// reset handler for 2D fallback
				document.getElementById('resetBtn').addEventListener('click', ()=>{
					drawOriginal();
					const fbtn = document.getElementById('flashToggle'); if(fbtn){ fbtn.classList.remove('on'); fbtn.classList.add('off'); fbtn.setAttribute('aria-checked','false'); const s = fbtn.querySelector('span'); if(s) s.textContent = 'Off'; }
					// clear lighting selection and canvas filters
					const modal = document.getElementById('moreOptionsModal');
					if(modal){
						const btns = modal.querySelectorAll('.lighting-option');
						btns.forEach(b=>{ b.setAttribute('aria-pressed','false'); });
						const def = modal.querySelector('.lighting-option[data-type="none"]'); if(def) def.setAttribute('aria-pressed','true');
						modal.style.display = 'none'; modal.setAttribute('aria-hidden','true');
						const moreBtn = document.getElementById('moreOptionsBtn'); if(moreBtn) moreBtn.setAttribute('aria-expanded','false');
					}
					// clear persistent flash and update composed filter
					window._persistentFlash = false;
					const canvas = document.getElementById('photo-canvas'); updateCanvasFilter();
					closeResultModal();
				});

				// Flash toggle wiring for 2D fallback
				const flashBtn2 = document.getElementById('flashToggle');
				if(flashBtn2){
					if(!flashBtn2.classList.contains('on')){ flashBtn2.classList.add('off'); flashBtn2.setAttribute('aria-checked','false'); const s0 = flashBtn2.querySelector('span'); if(s0) s0.textContent = 'Off'; }
					flashBtn2.addEventListener('click', ()=>{
						const isOn = flashBtn2.classList.toggle('on');
						flashBtn2.classList.toggle('off', !isOn);
						flashBtn2.setAttribute('aria-checked', isOn ? 'true' : 'false');
						const s = flashBtn2.querySelector('span'); if(s) s.textContent = isOn ? 'On' : 'Off';
						// persistent flag
						window._persistentFlash = !!isOn;
						if(isOn){
							// clear any active lighting selection for 2D fallback
							window._lightingType = 'none';
							const modal = document.getElementById('moreOptionsModal');
							if(modal){ const btns = modal.querySelectorAll('.lighting-option'); btns.forEach(b=>b.setAttribute('aria-pressed','false')); const def = modal.querySelector('.lighting-option[data-type="none"]'); if(def) def.setAttribute('aria-pressed','true'); }
						}
						// reapply effects to reflect flash immediately
						applyEffects({aperture: document.getElementById('aperture-slider').value, shutter: document.getElementById('shutter-slider').value, iso: document.getElementById('iso-slider').value, flash: isOn});
					});
				}
			document.getElementById('fl-try').addEventListener('click', ()=>{ closeResultModal(); });
			document.getElementById('fl-next').addEventListener('click', (e)=>{
				try{ e.preventDefault(); }catch(_){ }
				if(window.ForensicFlow && typeof ForensicFlow.onPractice4Finished === 'function'){
					ForensicFlow.onPractice4Finished();
				} else {
					try{ localStorage.setItem('practice4_done','true'); }catch(err){}
					window.location.href = '../quiz/quiz4.html';
				}
			});
		});
	</script>
	<div class="top-bar">
		<button class="back-btn" onclick="window.history.back()" aria-label="Back">
			<svg viewBox="0 0 32 32"><path d="M20.7 25.3a1 1 0 0 1-1.4 0l-8-8a1 1 0 0 1 0-1.4l8-8a1 1 0 1 1 1.4 1.4L13.42 16l7.3 7.3a1 1 0 0 1 0 1.4z"/></svg>
		</button>
		<div class="level-title">Level 4: Fingerprint</div>
		<div class="task-box">Task: Take a properly exposed photo of the vehicle with the evidens marker included.</div>
	</div>
	<div id="main-content">
			<div class="flex-row">
				<div class="flex-left">
					<div class="photo-box">
						<img id="source-image" src="../assets/fingerprint.png" alt="Fingerprint Evidence" style="display:none" />
						<canvas id="photo-canvas" aria-label="Photo preview"></canvas>
					</div>
					<div class="exposure-label">Exposure Meter: <span>GOOD EXPOSURE</span></div>
					<div class="exposure-slider">
						<div class="slider-track">
							<input id="exposure-slider" type="range" min="-3" max="3" value="0" step="0.1" class="slider">
						</div>
						<div class="ticks" aria-hidden="true">
							<span style="left:0%"></span><label style="left:0%">-3</label>
							<span style="left:16.66%"></span><label style="left:16.66%">-2</label>
							<span style="left:33.33%"></span><label style="left:33.33%">-1</label>
							<span style="left:50%"></span><label style="left:50%">0</label>
							<span style="left:66.66%"></span><label style="left:66.66%">1</label>
							<span style="left:83.33%"></span><label style="left:83.33%">2</label>
							<span style="left:100%"></span><label style="left:100%">3</label>
						</div>
					</div>
				</div>
				<div class="flex-right">
					<!-- Camera Modes -->
					<div class="modes" role="tablist" aria-label="Camera Modes">
						<button class="mode active" role="tab" aria-selected="true" data-mode="M">Manual (M)</button>
						<button class="mode" role="tab" aria-selected="false" data-mode="Tv">Shutter Priority (Tv)</button>
						<button class="mode" role="tab" aria-selected="false" data-mode="Av">Aperture Priority (Av)</button>
					</div>
					<!-- Header: title on the left, flash toggle on the right -->
					<div class="controls-title" style="display:flex; justify-content:space-between; align-items:center;">
						<span>Camera Controls</span>
						<div style="display:flex; align-items:center; gap:8px;">
							<!-- More Options button: toggles the hidden panel with additional controls -->
							<button id="moreOptionsBtn" class="btn more-options" aria-label="More Options" title="More Options" aria-expanded="false" aria-controls="moreOptionsModal">
								<svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M12 8a2 2 0 100-4 2 2 0 000 4zm0 6a2 2 0 100-4 2 2 0 000 4zm0 6a2 2 0 100-4 2 2 0 000 4z" fill="currentColor"/></svg>
							</button>
						</div>
						<!-- More options will open a modal instead of an inline panel -->
					</div>
					<div class="controls-inner">
						<div class="control-group" >
							<div class="control-label">&#9673; APERTURE: <span id="aperture-val">10</span></div>
							<input type="range" min="7.1" max="11" value="10" step="0.1" class="control-slider" id="aperture-slider">
							<div class="ticks" aria-hidden="true">
								<span style="left:0%"></span><label style="left:0%">f/7.1</label>
								<span style="left:25%"></span><label style="left:25%">f/8</label>
								<span style="left:50%"></span><label style="left:50%">f/9</label>
								<span style="left:75%"></span><label style="left:75%">f/10</label>
								<span style="left:100%"></span><label style="left:100%">f/11</label>
							</div>
						</div>
						<div class="control-group">
							<div class="control-label">&#128336; SHUTTER SPEED: <span id="shutter-val">1/400 SEC</span></div>
							<input type="range" min="80" max="250" value="125" step="1" class="control-slider" id="shutter-slider">
							<div class="ticks" aria-hidden="true">
								<span style="left:0%"></span><label style="left:0%">1/80</label>
								<span style="left:25%"></span><label style="left:25%">1/125</label>
								<span style="left:50%"></span><label style="left:50%">1/200</label>
								<span style="left:100%"></span><label style="left:100%">1/250</label>
							</div>
						</div>
						<div class="control-group">
							<div class="control-label">&#9728; ISO: <span id="iso-val">400</span></div>
							<input type="range" min="400" max="800" value="400" step="100" class="control-slider" id="iso-slider">
							<div class="ticks" aria-hidden="true">
								<span style="left:0%"></span><label style="left:0%">400</label>
								<span style="left:25%"></span><label style="left:25%">500</label>
								<span style="left:50%"></span><label style="left:50%">600</label>
								<span style="left:75%"></span><label style="left:75%">700</label>
								<span style="left:100%"></span><label style="left:100%">800</label>
							</div>
						</div>
						<div class="controls-btns">
							<button class="btn reset" id="resetBtn">Reset</button>
							<button class="btn submit" id="submitBtn">Submit</button>
						</div>
					</div>
				</div>
			</div>
        </div>
    </div>
	<!-- Camera Modes behavior (mode-based control enabling) -->
	<script>
		document.addEventListener('DOMContentLoaded', function(){
			const container = document.querySelector('.modes');
			if(!container) return;
			const buttons = Array.from(container.querySelectorAll('.mode'));

			function setDisabled(el, disabled){ if(!el) return; el.disabled = !!disabled; const grp = el.closest('.control-group'); if(grp){ grp.classList.toggle('control-disabled', !!disabled); } }
			function applyModeToControls(mode){
				const ap = document.getElementById('aperture-slider');
				const sh = document.getElementById('shutter-slider');
				const iso = document.getElementById('iso-slider');
				const ex = document.getElementById('exposure-slider');
				if(mode === 'M'){
					[ap, sh, iso, ex].forEach(el => setDisabled(el, false));
				}else if(mode === 'Tv'){
					setDisabled(sh, false);
					[ap, iso, ex].forEach(el => setDisabled(el, true));
				}else if(mode === 'Av'){
					setDisabled(ap, false);
					[sh, iso, ex].forEach(el => setDisabled(el, true));
				}
				try{ if(typeof scheduleApply === 'function') scheduleApply(); }catch(e){}
			}

			buttons.forEach(btn => {
				btn.addEventListener('click', () => {
					buttons.forEach(b => { b.classList.remove('active'); b.setAttribute('aria-selected','false'); });
					btn.classList.add('active');
					btn.setAttribute('aria-selected','true');
					const mode = btn.getAttribute('data-mode') || 'M';
					applyModeToControls(mode);
				});
			});

			// initialize to current active or default Manual
			const initial = (container.querySelector('.mode.active')?.getAttribute('data-mode')) || 'M';
			applyModeToControls(initial);
		});
	</script>
</body>
</html>